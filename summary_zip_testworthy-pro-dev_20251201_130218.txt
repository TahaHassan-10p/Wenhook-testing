
=== PROCESSING SUMMARY ===
Total chunks: 2
Successfully processed: 2
Failed chunks: 0
Processing date: 2025-12-01 13:02:18

=== CONTENT STARTS BELOW ===

FILE: testworthy-pro-dev/DOCKER_DEPLOYMENT.md
- File name and relative path: testworthy-pro-dev/DOCKER_DEPLOYMENT.md
- Purpose or role in the project: This markdown file serves as a comprehensive guide for deploying the TestWorthy Pro application using Docker and Docker Compose. It covers prerequisites, quick start instructions, various deployment options, environment configuration, available commands, architecture overview, production setup, monitoring, and troubleshooting.
- Main components, functions, classes, or constants with brief technical descriptions: The document is structured into sections. Key sections include 'Prerequisites' (Docker, Docker Compose, RAM, disk space), 'Quick Start' (cloning, configuring `.env`, running `./deploy.sh`), 'Deployment Options' (using NeonDB, local PostgreSQL, or production setup with Nginx), 'Environment Configuration' (lists required variables like `DATABASE_URL`, `SECRET_KEY`, AI API keys, and repository tokens), 'Available Commands' (details for the `./deploy.sh` script like `build`, `start`, `stop`, `migrate`, `seed`), 'Architecture' (describes the frontend, backend, PostgreSQL, and Nginx services, networking, and volumes), 'Production Deployment' (server requirements, SSL setup with certbot, domain setup, firewall configuration with ufw/firewall-cmd), 'Monitoring and Maintenance' (health checks, log monitoring, database backup/restore using `pg_dump`/`psql`, and update procedures), 'Troubleshooting' (common issues like port conflicts, database connection failures, and memory issues), 'Security Considerations', and 'Performance Optimization'.
- Important interactions or dependencies with other files or modules: This guide directly references and explains the usage of several other files in the project: `deploy.sh` (the main deployment script), `.env.example` and `.env` (for environment configuration), `docker-compose.yml`, `docker-compose.debug.yml` (for Docker service definitions), and `nginx.conf` (for the reverse proxy configuration).
- Notable implementation details, architectural patterns, or non-trivial techniques: The guide outlines a flexible Docker-based deployment architecture that can be adapted for different environments. It supports both external (NeonDB) and local databases. It also details a production-ready setup using Nginx as a reverse proxy with SSL termination. The use of a single `deploy.sh` script abstracts the underlying Docker Compose commands, simplifying management for the user. The document provides specific commands for server setup, including firewall rules for Ubuntu/Debian and RHEL/CentOS systems.
- Special configurations, assets, or third-party libraries if present: The guide requires Docker, Docker Compose, and suggests using `certbot` for SSL certificate generation. It documents the use of a PostgreSQL database (either local or NeonDB) and an optional Nginx reverse proxy. It also specifies the environment variables needed for third-party services like OpenAI, Gemini, Anthropic, GitHub, and GitLab.

FILE: testworthy-pro-dev/PERFORMANCE_OPTIMIZATION_PLAN.md
- File name and relative path: testworthy-pro-dev/PERFORMANCE_OPTIMIZATION_PLAN.md
- Purpose or role in the project: This document is a detailed performance analysis and optimization plan for the TestWorthy Pro application. It identifies critical performance bottlenecks in both the backend and frontend and outlines a phased approach to address them.
- Main components, functions, classes, or constants with brief technical descriptions: The plan identifies six critical issues: 1. N+1 query problem in multiple API routes, causing excessive database queries. 2. Missing pagination in list endpoints, leading to large data loads. 3. Inefficient frontend data loading patterns, fetching entire datasets instead of specific records. 4. Aggressive polling on the frontend, causing unnecessary server load. 5. No data caching, resulting in redundant API calls. 6. Large payload transfers due to returning full objects instead of summaries. It sets performance metric targets for page load times, query counts, and bundle size. The optimization plan is divided into three phases: Phase 1 (Critical Backend Fixes) focuses on fixing N+1 queries with SQLAlchemy's `joinedload`, adding pagination with `offset` and `limit`, and creating optimized summary endpoints. Phase 2 (Frontend Optimization) involves implementing virtual lists with `react-window`, request caching with `react-query`, code splitting with `React.lazy`, and optimizing polling with the Page Visibility API. Phase 3 (Advanced Optimizations) includes database indexing, response compression with GZip middleware, using WebSockets for real-time updates, and implementing server-side filtering and search. The document also lists "Quick Wins" like adding loading states and debouncing inputs.
- Important interactions or dependencies with other files or modules: The plan directly references code snippets and line numbers from backend files like `app/api/activity_routes.py`, `case_routes.py`, etc., and frontend files like `TestRunDetailsModule.tsx`. It suggests adding new third-party libraries to the frontend, such as `react-window`, `react-window-infinite-loader`, and `@tanstack/react-query`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The core of the backend optimization is to move from lazy loading (default in SQLAlchemy) to eager loading (`joinedload`) to solve N+1 problems. The frontend plan proposes a shift from a naive data fetching model (`useEffect`) to a more sophisticated one using a state management library like React Query for caching, deduplication, and background refetching. Virtualization (`react-window`) is proposed to handle large lists efficiently by only rendering visible items. The plan also details creating a `useSmartPolling` custom hook to reduce server load from background tabs.
- Special configurations, assets, or third-party libraries if present: Recommends installing `pytest-benchmark` and `lighthouse` for performance auditing. Suggests adding `react-window`, `react-window-infinite-loader`, and `@tanstack/react-query` to the frontend.

FILE: testworthy-pro-dev/PRODUCTION_DEPLOY.md
- File name and relative path: testworthy-pro-dev/PRODUCTION_DEPLOY.md
- Purpose or role in the project: This document is a step-by-step guide for deploying the TestWorthy Pro application to a production environment on an internal network using an IP address instead of a domain name. It is specifically tailored for an Ubuntu server.
- Main components, functions, classes, or constants with brief technical descriptions: The guide details the production architecture, mapping development ports (3000/8000) to production ports (4000/8020) on a specific internal IP (10.0.3.117). It provides step-by-step instructions for: 1. Installing Docker and Git on Ubuntu. 2. Cloning the repository. 3. Transferring Vertex AI credentials using `scp`. 4. Creating and configuring a `.env.production` file with production-specific variables like `POSTGRES_PASSWORD`, `SECRET_KEY`, and the `VITE_API_BASE` URL pointing to the backend's IP and port. 5. Creating a `docker-compose.production.yml` file which defines production services (postgres, migrate, backend, frontend, seed) with persistent volumes (`postgres_data_prod`), a dedicated network (`testworthy_network_prod`), health checks, and restart policies (`unless-stopped`). 6. Configuring the UFW firewall to allow traffic on ports 4000 and 8020 only from the internal subnet. 7. Building and deploying the application using `docker compose`. 8. Setting up a systemd service (`testworthy-prod.service`) to ensure the application starts automatically on boot. 9. Configuring automated backups using a shell script and a cron job. 10. A list of production management and monitoring commands. It also includes a troubleshooting section for common issues.
- Important interactions or dependencies with other files or modules: This guide requires creating two new files: `.env.production` and `docker-compose.production.yml`. It interacts with Dockerfiles (`Dockerfile.backend`, `Dockerfile.frontend`) during the build process. It also mounts the Vertex AI JSON key file into the backend and related containers.
- Notable implementation details, architectural patterns, or non-trivial techniques: The deployment is designed for an internal network, so it exposes Docker ports directly without a reverse proxy like Nginx, simplifying the setup. It uses `scp` for secure file transfer. The `docker-compose.production.yml` is distinct from the development `docker-compose.yml`, using different container names, volumes, and networks to isolate production from development environments. The guide includes a robust backup strategy that backs up the database, uploads, and configuration files. It also demonstrates how to create a systemd service for managing the Docker Compose application as a standard Linux service. The use of `--env-file .env.production` ensures that production secrets are loaded correctly.
- Special configurations, assets, or third-party libraries if present: The deployment relies on Docker, Docker Compose, Git, UFW (firewall), and systemd. It requires a Vertex AI service account JSON file (`testworthy-pro-0ca9abbb75ba.json`). Default login credentials for seeded users are also documented.

FILE: testworthy-pro-dev/deploy.sh
- File name and relative path: testworthy-pro-dev/deploy.sh
- Purpose or role in the project: This is a master deployment script for managing the TestWorthy Pro Docker environment. It provides a user-friendly command-line interface that abstracts away the complexity of Docker Compose commands for common operations like building, starting, stopping, and cleaning up the application.
- Main components, functions, classes, or constants with brief technical descriptions: The script is written in Bash and uses `set -e` to exit immediately if any command fails. It defines several helper functions: `print_status`, `print_success`, `print_warning`, `print_error` for colored console output. `check_docker` verifies that Docker and Docker Compose are installed and running. `check_env` checks for a `.env` file and copies it from `.env.example` if it doesn't exist, prompting the user to edit it. `build_images` builds the backend and frontend Docker images. `start_services` brings up the Docker containers, with logic to handle optional arguments for using a local database (`local-db`) and an Nginx proxy (`with-nginx`). `show_status` displays the running services and their URLs. `run_migrations` executes Alembic database migrations inside the backend container. `seed_database` runs Python scripts to populate the database with initial data. `stop_services` shuts down the containers. `cleanup` stops containers and optionally removes volumes and images. `view_logs` tails the logs for all or a specific service. The `main` function is a large `case` statement that parses the first command-line argument (`$1`) to call the appropriate function.
- Important interactions or dependencies with other files or modules: This script is the primary entry point for managing the Docker environment defined in `docker-compose.yml`. It depends on `Dockerfile.backend` and `Dockerfile.frontend` for building images. It also relies on the `.env` file for environment variables. It executes scripts within the backend container, such as `alembic upgrade head`, `init_ai_settings.py`, `seed_db.py`, and `seed_admin.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script provides a clean command-line API (e.g., `./deploy.sh deploy local-db`) that simplifies complex multi-step processes. It uses `docker-compose --profile production` to conditionally start the `nginx` service, demonstrating the use of Docker Compose profiles. The `start_services` function includes a `sleep` and a `while` loop with a timeout to wait for the backend service to become healthy before proceeding, which is a good practice for ensuring service dependencies are met.
- Special configurations, assets, or third-party libraries if present: The script requires a Bash-compatible shell, Docker, and Docker Compose.

FILE: testworthy-pro-dev/docker-compose.production.yml
- File name and relative path: testworthy-pro-dev/docker-compose.production.yml
- Purpose or role in the project: This Docker Compose file defines the multi-container application setup specifically for a production deployment on an internal network. It orchestrates the postgres database, backend API, frontend application, and one-off tasks like database migration and seeding.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines five services: `postgres` (using `postgres:15-alpine` image, persists data in a named volume `postgres_data_prod`), `migrate` (a one-off container that runs `alembic upgrade head` and then exits), `backend` (the FastAPI application, built from `Dockerfile.backend`), `frontend` (the Next.js/Vite application, built from `Dockerfile.frontend`), and `seed` (a one-off container that runs `master_seed.py`). All services are connected to a custom bridge network `testworthy_network_prod`. It makes extensive use of environment variables (e.g., `${POSTGRES_PASSWORD}`) which are intended to be supplied from an external `.env.production` file.
- Important interactions or dependencies with other files or modules: This file is designed to be used with a `.env.production` file. It builds images using `Dockerfile.backend` and `Dockerfile.frontend`. It mounts several local paths as volumes: `./testworthy-pro-backend/uploads` for file storage, `./testworthy-pro-backend/logs` for application logs, and the Vertex AI credential file `./testworthy-pro-backend/testworthy-pro-0ca9abbb75ba.json` into the containers that need it.
- Notable implementation details, architectural patterns, or non-trivial techniques: The services have explicit dependencies defined with `depends_on`. For example, the `backend` service waits for `postgres` to be `service_healthy` and for the `migrate` service to be `service_completed_successfully`. This ensures services start in the correct order. Health checks are defined for `postgres`, `backend`, and `frontend` to allow Docker to monitor their status. The `frontend` service build uses a build argument (`VITE_API_BASE`) to hardcode the backend IP address into the static frontend assets, a common pattern for deployments where the API URL is fixed. The `migrate` and `seed` services use `restart: "no"` because they are one-off tasks. The main application services (`postgres`, `backend`, `frontend`) use `restart: unless-stopped` for resilience.
- Special configurations, assets, or third-party libraries if present: Relies on Docker Compose. Uses standard Docker images for `postgres:15-alpine`. It maps host port 8020 to the backend's container port 8000, and host port 4000 to the frontend's container port 80, exposing the application on the specified production ports.

FILE: testworthy-pro-dev/docker-compose.yml
- File name and relative path: testworthy-pro-dev/docker-compose.yml
- Purpose or role in the project: This is the main Docker Compose file for setting up the local development and general-purpose Docker environment. It defines and links all the necessary services for the application to run.
- Main components, functions, classes, or constants with brief technical descriptions: It defines six services: `postgres` (database using `postgres:15-alpine` image, exposes port 5433 for local connections), `backend` (FastAPI app, built from `Dockerfile.backend`, exposes port 8000), `migrate` (one-off container for running `alembic upgrade head`), `seed` (one-off container for running `master_seed.py`), `frontend` (Next.js/Vite app, built from `Dockerfile.frontend`, exposes port 3000), and `nginx` (an optional reverse proxy using the `nginx:alpine` image). All services are connected via the `testworthy_network` bridge network. It uses a named volume `postgres_data` for database persistence.
- Important interactions or dependencies with other files or modules: This file uses environment variables from a `.env` file to configure secrets and other settings (e.g., `${SECRET_KEY}`, `${OPENAI_API_KEY}`). It builds images from `Dockerfile.backend` and `Dockerfile.frontend`. It mounts local directories like `./testworthy-pro-backend/uploads`, `./testworthy-pro-backend/logs`, the Vertex AI credential file, `./nginx.conf`, and `./ssl` into the respective containers. The `backend`'s `DATABASE_URL` is hardcoded to connect to the `postgres` service via its Docker network hostname.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `nginx` service is defined with `profiles: [production]`, meaning it will only start if the `production` profile is activated (e.g., `docker-compose --profile production up`). This allows for an optional, production-like setup within the same file. Health checks are defined for `postgres`, `backend`, and `frontend` to ensure container health. The `depends_on` keyword is used with conditions (`service_healthy`, `service_completed_successfully`) to enforce a strict startup order, preventing the backend from starting before the database is ready and migrations are complete.
- Special configurations, assets, or third-party libraries if present: Depends on Docker Compose. Uses official images for `postgres:15-alpine` and `nginx:alpine`.

FILE: testworthy-pro-dev/next.config.js
- File name and relative path: testworthy-pro-dev/next.config.js
- Purpose or role in the project: This file is the configuration for a Next.js frontend application. It customizes the build process, environment variables, server behavior, and security settings for the frontend.
- Main components, functions,classes, or constants with brief technical descriptions: The file exports a configuration object `nextConfig`. Key properties are: `output: 'standalone'` which optimizes the output for Docker by creating a self-contained folder with all necessary files. `env` sets the public environment variable `NEXT_PUBLIC_API_URL`, falling back to `http://localhost:8000` if not set externally. `images: { unoptimized: true }` disables Next.js's default image optimization, which is often necessary in Docker environments where image processing libraries might not be available. `experimental` enables server-side rendering optimizations. `webpack` is a function that modifies the Webpack configuration; here it's used to disable `splitChunks` on the server in production to optimize bundling. `headers` is an async function that returns custom HTTP security headers (`X-Frame-Options`, `X-Content-Type-Options`, `Referrer-Policy`) for all routes. `rewrites` is an async function that configures an API proxy, rewriting requests from the frontend's `/api/:path*` to the backend API URL, which is a common pattern to avoid CORS issues in development.
- Important interactions or dependencies with other files or modules: This configuration is specific to the Next.js framework. It heavily relies on environment variables, particularly `process.env.NEXT_PUBLIC_API_URL`, which is used for both the `env` block and the `rewrites` proxy.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `output: 'standalone'` setting is a crucial optimization for creating efficient Docker images with Next.js. The API rewrite functionality is a powerful feature for simplifying frontend code, as it allows API calls to be made to the same origin (`/api/...`) from the browser's perspective, while Next.js handles proxying them to the actual backend server. The webpack modification is a server-side performance optimization.
- Special configurations, assets, or third-party libraries if present: This configuration file is for the Next.js framework.

FILE: testworthy-pro-dev/package-lock.json
- File name and relative path: testworthy-pro-dev/package-lock.json
- Purpose or role in the project: This file is an auto-generated lockfile created by `npm`. It records the exact versions of every dependency (and their sub-dependencies) that were installed for the project. Its purpose is to ensure that the project can be installed consistently across different environments, preventing issues caused by unexpected dependency updates.
- Main components, functions, classes, or constants with brief technical descriptions: The file is a large JSON object. The root object has a `name` ("testworthy-pro"), `lockfileVersion` (3), and `packages` object. The `packages` object lists every installed package. The entry for `""` (the root package) lists the direct `dependencies` (`lucide-react`, `react`, `react-dom`, `sonner`) and `devDependencies` (`@types/react`, `@types/react-dom`). Subsequent entries under `node_modules/` detail each package's `version`, `resolved` URL from the npm registry, its `integrity` hash (for security), `license`, and its own dependencies (`peerDependencies`, `dependencies`).
- Important interactions or dependencies with other files or modules: This file is directly linked to `package.json`. When `npm install` is run, `npm` reads the dependencies from `package.json` and installs versions that satisfy the specified ranges, then records the exact installed versions in `package-lock.json`. Subsequent `npm install` runs will use this lockfile to install the exact same versions.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file represents the dependency tree of the project. The `lockfileVersion: 3` format is the modern, more deterministic version used by recent npm versions. It includes a `peerDependencies` section for packages that expect other packages to be installed at the project root.
- Special configurations, assets, or third-party libraries if present: This file tracks dependencies from the npm registry. Key libraries listed include `react` v19.2.0, `react-dom` v19.2.0, `lucide-react` for icons, and `sonner` for notifications.

FILE: testworthy-pro-dev/package.json
- File name and relative path: testworthy-pro-dev/package.json
- Purpose or role in the project: This is the manifest file for a Node.js project, located at the root of the `testworthy-pro-dev` directory. It defines the project's direct dependencies and development dependencies.
- Main components, functions, classes, or constants with brief technical descriptions: The file is a JSON object with two main sections: `dependencies` and `devDependencies`.
- `dependencies`: Lists packages required for the application to run. This includes `lucide-react` (^0.554.0) for icons, `react` (^19.2.0) and `react-dom` (^19.2.0) as the core UI library, and `sonner` (^2.0.7) for toast notifications.
- `devDependencies`: Lists packages needed only for development and building. This includes `@types/react` (^19.2.6) and `@types/react-dom` (^19.2.3) for TypeScript type definitions for React.
- Important interactions or dependencies with other files or modules: This file is used by the `npm` (Node Package Manager) to install the necessary packages into the `node_modules` directory. The `package-lock.json` file is generated based on the dependencies listed here. The dependencies listed here are likely used by the frontend part of the application.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of caret `^` prefixes for versions allows npm to install minor and patch updates automatically, while keeping the major version fixed. This is a standard practice in Node.js projects. The separation of `dependencies` and `devDependencies` is also standard, ensuring that only necessary packages are installed in a production environment.
- Special configurations, assets, or third-party libraries if present: This file defines dependencies managed by npm.

FILE: testworthy-pro-dev/run.mD
- File name and relative path: testworthy-pro-dev/run.mD
- Purpose or role in the project: This markdown file (.mD seems to be a typo for .md) is a setup guide for developers to install and run the TestWorthy Pro project locally without using Docker. It covers setting up the PostgreSQL database, backend, and frontend individually.
- Main components, functions, classes, or constants with brief technical descriptions: The guide is divided into sections: 'Prerequisites' (Python 3.12, Node.js 18+, PostgreSQL 14+), 'PostgreSQL Setup' (installing PostgreSQL, creating a database and user with SQL commands), 'Backend Setup' (creating a Python virtual environment, installing dependencies from `requirements.txt`, seeding the database with `master_seed.py`, and running the server with `python run.py`), and 'Frontend Setup' (creating a `.env` file, installing dependencies with `npm install`, and running the dev server with `npm run dev`). It also includes a 'Project Architecture' overview, a 'Troubleshooting' section for common issues like port conflicts and Python version problems, and a 'Database Management' section with commands for resetting and backing up the database. A reference for required environment variables for both backend and frontend is also provided.
- Important interactions or dependencies with other files or modules: This guide instructs the user on how to interact with several key files: `testworthy-pro-backend/.env` (for backend configuration), `testworthy-pro-backend/requirements.txt` (for Python dependencies), `testworthy-pro-backend/reset_database.py`, `testworthy-pro-backend/master_seed.py`, `testworthy-pro-backend/run.py`, `testworthy-pro-frontend/.env` (for frontend config), and `testworthy-pro-frontend/package.json` (via `npm install`).
- Notable implementation details, architectural patterns, or non-trivial techniques: The guide provides separate instructions for PowerShell (Windows) and Bash-like shells (Git Bash, WSL, Linux, macOS), which is helpful for cross-platform development. The backend setup follows a standard Python development workflow: create a virtual environment, activate it, install dependencies, run database scripts, and then start the application.
- Special configurations, assets, or third-party libraries if present: Requires manual installation of Python, Node.js, and PostgreSQL.

FILE: testworthy-pro-dev/src/app/api/health/route.ts
- File name and relative path: testworthy-pro-dev/src/app/api/health/route.ts
- Purpose or role in the project: This is a Next.js API route that serves as a health check endpoint. It's used to verify that the frontend application server is running and responsive, which is particularly useful in containerized environments like Docker for health checks.
- Main components, functions, classes, or constants with brief technical descriptions: The file exports a single asynchronous function `GET`. This function handles HTTP GET requests to `/api/health`. Inside a `try...catch` block, it constructs a `healthData` object containing the service `status` ('healthy'), a `timestamp`, the `service` name ('testworthy-frontend'), a `version`, and the process `uptime`. It then returns this data as a JSON response with a 200 OK status code using `NextResponse.json`. If an error occurs, the `catch` block returns a JSON response with a status of 'unhealthy', the error message, and a 503 Service Unavailable status code.
- Important interactions or dependencies with other files or modules: This file uses the `NextResponse` object from the `next/server` module, which is part of the Next.js framework for handling API route responses. It uses the Node.js `process.uptime()` function to get the server's uptime.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard implementation of a health check endpoint. Including metadata like `timestamp`, `version`, and `uptime` in the response is a good practice for monitoring and debugging purposes. The error handling ensures that even if the server is in a problematic state but still able to respond, it will correctly report itself as 'unhealthy'.
- Special configurations, assets, or third-party libraries if present: This file is part of a Next.js application.

FILE: testworthy-pro-dev/testworthy-pro-backend/AI_PROVIDER_REFACTORING.md
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/AI_PROVIDER_REFACTORING.md
- Purpose or role in the project: This document outlines a significant refactoring of the AI provider architecture in the backend. It describes the transition from a monolithic AI client to a modular, provider-specific structure.
- Main components, functions, classes, or constants with brief technical descriptions: The document details the new file structure under `app/services/`. A new directory `ai_providers/` now contains separate modules for each AI service: `openai_provider.py`, `gemini_provider.py`, `vertex_provider.py`, `anthropic_provider.py`, and `openrouter_provider.py`. A new `unified_ai_client.py` was created to act as a facade or router that delegates calls to the appropriate provider module, maintaining a consistent interface. The old `ai_processor.py` was renamed to the more descriptive `project_import_processor.py`. The old monolithic client was backed up as `ai_client_legacy.py.bak`. The benefits cited are easier maintenance, better organization, simpler testing, and reduced code duplication.
- Important interactions or dependencies with other files or modules: It shows how `chunk_processor.py` was updated to import and use the new `UnifiedAIClient`. It provides a "Migration Guide" showing the code change required, from `from ..services.ai_client import AIClient` to `from ..services.unified_ai_client import UnifiedAIClient`. It also mentions that `app/api/ai_routes.py` might need updating.
- Notable implementation details, architectural patterns, or non-trivial techniques: This refactoring implements the Strategy pattern and a Facade pattern. Each provider is a separate "strategy" for generating content, and the `UnifiedAIClient` acts as a facade that hides the complexity of choosing and calling the correct provider from the rest of the application. This greatly improves modularity and adheres to the Single Responsibility Principle.
- Special configurations, assets, or third-party libraries if present: No new libraries are mentioned, but the refactoring impacts how the application interacts with various AI provider APIs (OpenAI, Gemini, Vertex AI, Anthropic, OpenRouter).

FILE: testworthy-pro-dev/testworthy-pro-backend/DATABASE_SETUP.md
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/DATABASE_SETUP.md
- Purpose or role in the project: This document provides a comprehensive guide for setting up and managing the Testworthy Pro database from scratch, intended for developers working locally.
- Main components, functions, classes, or constants with brief technical descriptions: The guide describes the database architecture, which relies on SQLAlchemy Models (`app/database/models.py`) as the single source of truth. Table creation is handled automatically on application startup via `Base.metadata.create_all()`. Seed data is populated by `master_seed.py`. The 'First Time Setup' section details creating the PostgreSQL database and user, configuring the `.env` file with `DATABASE_URL`, installing dependencies, creating tables by running `run.py`, and then seeding the data. It also covers how to perform a complete database reset using `reset_database.py`. The 'Migration Workflow' section explains how to add new tables (by defining a new model and restarting the app) and new columns (by adding to the model and either using a migration script or resetting the dev database). It includes a specific example of adding the `test_run_id` column to the `test_case_defects` table.
- Important interactions or dependencies with other files or modules: The document is centered around the interaction between `app/database/models.py` (schema definition), `app/main.py` (which calls `create_all`), `run.py` (the script to start the app), `master_seed.py` (data population), and `reset_database.py` (for teardown/rebuild). It also references `migrations/add_test_run_id_to_defects.sql` as an example of a manual migration script.
- Notable implementation details, architectural patterns, or non-trivial techniques: The database setup uses a "code-first" approach where the Python SQLAlchemy models define the database schema. The reliance on `Base.metadata.create_all()` is a simple schema management strategy suitable for development, but the guide correctly notes that for production, a more robust migration tool like Alembic is recommended and shows an example of a future Alembic workflow.
- Special configurations, assets, or third-party libraries if present: Requires PostgreSQL 12+ and Python 3.8+. The key Python library is SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/README.md
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/README.md
- Purpose or role in the project: This is the main README file for the backend portion of the Testworthy Pro application. It provides a quick start guide, an overview of database management, a list of features, and a description of the project structure.
- Main components, functions, classes, or constants with brief technical descriptions: The 'Quick Start' section gives concise commands for installing dependencies, configuring the `.env` file, setting up the database (either for the first time or by resetting), and starting the FastAPI server. It also lists the default credentials for the seeded users. The 'Database Management' section summarizes the architecture: models in `models.py` are the source of truth, tables are auto-created on startup, and `master_seed.py`/`reset_database.py` are used for data management. It lists key features like JWT authentication, role-based access control, and AI integration. The 'Project Structure' section provides a tree view of the backend directory, highlighting the roles of key subdirectories like `api/` (routes), `auth/` (JWT), `core/` (config), `database/` (models), `schemas/` (Pydantic), and `services/` (business logic).
- Important interactions or dependencies with other files or modules: This README serves as an entry point to understanding the backend codebase. It directly references and explains the purpose of key files such as `app/database/models.py`, `app/main.py`, `master_seed.py`, `reset_database.py`, and `DATABASE_SETUP.md`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The document emphasizes the "code-first" database architecture where SQLAlchemy models in `app/database/models.py` define the schema, which is automatically created by `Base.metadata.create_all()` in `app/main.py`. This is a common pattern in FastAPI/SQLAlchemy applications for rapid development.
- Special configurations, assets, or third-party libraries if present: The backend is built with FastAPI and uses SQLAlchemy for the ORM with a PostgreSQL database. It mentions that API documentation is available via Swagger UI (`/docs`) and ReDoc (`/redoc`), which are built-in features of FastAPI.

FILE: testworthy-pro-dev/testworthy-pro-backend/add_performance_indexes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/add_performance_indexes.py
- Purpose or role in the project: This is a standalone Python script designed to improve database performance by creating several composite indexes on frequently queried columns. This is likely part of the performance optimization plan.
- Main components, functions, classes, or constants with brief technical descriptions: The script contains one main function, `create_performance_indexes`. This function first creates a SQLAlchemy engine using the `DATABASE_URL` from the application's settings. It then defines a list of `Index` objects to be created. Each `Index` object is a composite index, targeting multiple columns that are often filtered or sorted together. The indexes include: `idx_test_executions_run_status` on `(run_id, status)`, `idx_test_cases_project_suite` on `(project_id, suite_id)`, and `idx_activities_case_created` on `(test_case_id, created_at DESC)`, among others. The script iterates through this list, checks if the index already exists in the `pg_indexes` system catalog to avoid errors, and creates it if it doesn't.
- Important interactions or dependencies with other files or modules: The script imports `settings` from `app.core.config` to get the database connection string. It also imports the SQLAlchemy model classes (`TestCase`, `TestExecution`, etc.) from `app.database.models` to define the indexes on them.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script is idempotent; it checks for the existence of an index before attempting to create it, so it can be run multiple times without causing errors. This is a robust way to manage schema changes via script. The indexes are strategically chosen to cover common query patterns identified in the performance optimization plan, such as filtering executions by run and status, or fetching activities for a specific case ordered by date.
- Special configurations, assets, or third-party libraries if present: The script uses the SQLAlchemy library to define and create the database indexes.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/env.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/env.py
- Purpose or role in the project: This is the main configuration and runtime environment script for Alembic, a database migration tool for SQLAlchemy. It configures how Alembic connects to the database and discovers the database models to generate and run migrations.
- Main components, functions, classes, or constants with brief technical descriptions: The script sets up the `target_metadata` for Alembic's 'autogenerate' feature by importing `models.Base.metadata` from the application's database models. It defines two main functions: `run_migrations_offline()` for generating SQL scripts without a live database connection, and `run_migrations_online()` for connecting to a database and applying migrations directly. The `run_migrations_online` function is notable because it's configured to prioritize the `DATABASE_URL` from the environment variables over the one in `alembic.ini`, making it flexible for different environments (like Docker vs. local).
- Important interactions or dependencies with other files or modules: This script is the core of the Alembic migration system. It imports `models` from `app/database/models.py` to get the schema definition (`Base.metadata`). It reads configuration from `alembic.ini` but can be overridden by the `DATABASE_URL` environment variable.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script dynamically adds the parent application directory (`app`) to the system path (`sys.path.insert`) to ensure it can import the application's models. The logic to use `os.environ.get("DATABASE_URL")` demonstrates a common pattern for making Alembic configurations environment-agnostic.
- Special configurations, assets, or third-party libraries if present: This file is part of the Alembic library setup.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/1764092989_add_self_healing_tables.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/1764092989_add_self_healing_tables.py
- Purpose or role in the project: This is an Alembic migration script. Its purpose is to add new tables and columns to the database schema to support the "self-healing test case" feature, which likely involves GitHub integration and pull request analysis.
- Main components, functions, classes, or constants with brief technical descriptions: The script defines `upgrade()` and `downgrade()` functions. The `upgrade()` function adds several new columns to the existing `repository_configs` and `pr_analyses` tables, such as `repository_name`, `auto_analyze_prs`, `pr_description`, `diff_content`, etc. It then creates two new tables: `test_case_deltas` to store suggested changes to test cases based on PR analysis, and `integration_logs` to log events from repository integrations. The script is written defensively: it uses `sa.inspect` to check if columns or tables already exist before attempting to add or create them, making the migration rerunnable. The `downgrade()` function reverses these changes by dropping the new tables and columns.
- Important interactions or dependencies with other files or modules: This script modifies the database schema defined in `app/database/models.py`. The new tables `test_case_deltas` and `integration_logs` correspond to new models that would have been added to `models.py`. It has a `down_revision` identifier pointing to a previous migration, `add_ai_settings`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of `op.get_bind()` and `sa.inspect(connection)` to check the live database schema before making changes is a robust migration technique. It prevents errors if the migration is run on a database that has already been partially or fully updated. The new tables establish relationships with existing ones through foreign keys, e.g., `test_case_deltas` links to `pr_analyses`, `test_cases`, and `users`.
- Special configurations, assets, or third-party libraries if present: This script is for the Alembic migration tool and uses SQLAlchemy's core expression language for schema manipulation.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/23da52e9f1eb_initial_postgresql_migration.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/23da52e9f1eb_initial_postgresql_migration.py
- Purpose or role in the project: This script appears to be the initial Alembic migration file, responsible for creating the entire database schema from scratch. It defines all the tables and their relationships for the application.
- Main components, functions, classes, or constants with brief technical descriptions: The script defines `upgrade()` and `downgrade()` functions. The `upgrade()` function is extensive. First, it explicitly creates several PostgreSQL ENUM types (`userrole`, `milestonestatus`, `testcasepriority`, etc.) by executing raw SQL, checking if they already exist to prevent errors. Then, it uses `op.create_table()` for each table in the application, including `users`, `projects`, `milestones`, `test_suites`, `test_cases`, `test_runs`, `test_executions`, and many others. For each table, it defines all columns with their types, constraints (primary keys, foreign keys), and indexes. It defensively checks if tables and indexes already exist before creating them. The `downgrade()` function contains the corresponding `op.drop_table()` and `op.drop_index()` commands to reverse the entire schema creation.
- Important interactions or dependencies with other files or modules: This script is the foundational migration for the database. It reflects the entire schema defined in the `app/database/models.py` file at the time it was created. Its `down_revision` is `None`, indicating it is the first migration.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script demonstrates a robust way to handle ENUM types in PostgreSQL with Alembic by executing `CREATE TYPE` with an existence check (`SELECT 1 FROM pg_type WHERE typname = ...`). This avoids common issues with Alembic's default ENUM handling. The check-before-create logic for both tables (`inspector.get_table_names()`) and indexes (`conn.execute(sa.text(...))`) makes this initial migration idempotent, meaning it can be run safely on a database that might already have some of the schema.
- Special configurations, assets, or third-party libraries if present: This script is for the Alembic migration tool.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/abc123_add_github_tables.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/abc123_add_github_tables.py
- Purpose or role in the project: This is an Alembic migration script for adding tables and columns related to GitHub integration features. It appears to be substantively identical to `1764092989_add_self_healing_tables.py`, suggesting a potential branching or duplication issue in the migration history.
- Main components, functions, classes, or constants with brief technical descriptions: The script defines `upgrade()` and `downgrade()` functions. The `upgrade()` function adds new columns to the `repository_configs` and `pr_analyses` tables (e.g., `repository_name`, `diff_content`, `files_changed`). It then creates two new tables: `test_case_deltas` for storing AI-suggested test case changes and `integration_logs` for logging webhook events. It uses `sa.inspect` to check if schema elements already exist before creating them. The `downgrade()` function reverses these changes.
- Important interactions or dependencies with other files or modules: It modifies the database schema. Its `down_revision` is set to `add_ai_settings`, indicating it branches from that migration. The content is the same as another migration file, which is a significant detail.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script is idempotent due to its use of existence checks before creating tables or adding columns. The content duplication with another migration file is a notable issue that would likely need to be resolved with an Alembic merge migration.
- Special configurations, assets, or third-party libraries if present: Uses Alembic and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/add_ai_settings.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/add_ai_settings.py
- Purpose or role in the project: This is an Alembic migration script that adds a new table, `ai_settings`, to the database schema.
- Main components, functions, classes, or constants with brief technical descriptions: The script has an `upgrade()` function that creates the `ai_settings` table using `op.create_table()`. The table includes columns for `id`, `user_id`, `setting_key`, `setting_value` (as JSON), and timestamps. It also creates an index on the `id` column. The `downgrade()` function reverses this by dropping the index and the table. It checks if the table already exists before creating it.
- Important interactions or dependencies with other files or modules: This migration adds a table that corresponds to the `AISettings` model in `app/database/models.py`. It has a `down_revision` pointing to the initial migration `23da52e9f1eb`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script uses `inspector.get_table_names()` to ensure it doesn't try to create a table that already exists, making it safe to re-run.
- Special configurations, assets, or third-party libraries if present: This script is for the Alembic migration tool.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/add_missing_test_case_columns.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/add_missing_test_case_columns.py
- Purpose or role in the project: This Alembic migration script adds several missing columns to the `test_cases` table to align the schema with updated application requirements.
- Main components, functions, classes, or constants with brief technical descriptions: The script defines `upgrade()` and `downgrade()` functions. The `upgrade()` function uses `op.add_column()` to add the following columns to the `test_cases` table if they do not already exist: `case_number`, `project_id`, `description`, `pr_url`, `assigned_to_id`, and `updated_at`. It also adds foreign key constraints for `project_id` and `assigned_to_id`. The `downgrade()` function reverses these changes by dropping the columns and their constraints.
- Important interactions or dependencies with other files or modules: This script alters the `test_cases` table, which corresponds to the `TestCase` model in `app/database/models.py`. Its `down_revision` points to `add_ai_settings`, indicating it's another branch in the migration history.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script uses `sa.inspect` to get existing columns and adds new columns one by one, checking for existence before each operation. This makes the migration robust and rerunnable. Foreign key creation is wrapped in a `try...except` block to handle cases where the constraint might already exist.
- Special configurations, assets, or third-party libraries if present: This is an Alembic migration script.

FILE: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/merge_heads_2025.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/alembic/versions/merge_heads_2025.py
- Purpose or role in the project: This is a special type of Alembic migration script known as a "merge" migration. Its purpose is to resolve a split in the migration history where multiple independent migrations (or "heads") were created from the same parent. This script unifies these branches into a single new head.
- Main components, functions, classes, or constants with brief technical descriptions: The script has empty `upgrade()` and `downgrade()` functions, as its sole purpose is to link migration histories, not to make schema changes itself. The crucial part is the `down_revision` variable, which is a tuple containing the revision IDs of all the migration heads it is merging: `abc123_add_github_tables`, `add_missing_test_case_columns`, and `add_self_healing_tables`.
- Important interactions or dependencies with other files or modules: This script resolves the divergent migration history created by the three scripts listed in `down_revision`. After this migration is applied, Alembic will see a single, linear history again.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard Alembic pattern for resolving a "multiple heads" issue, which typically occurs when developers work on database changes in parallel branches and then merge their work.
- Special configurations, assets, or third-party libraries if present: This is an Alembic migration script.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/aggregate_results_sample_response.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/aggregate_results_sample_response.json
- Purpose or role in the project: This JSON file is a sample response from the AI aggregation process. It represents the structured output after an AI has analyzed multiple chunks of code, generated test cases, and organized them into a coherent project structure. It likely serves as a mock response for testing or as a reference for the expected output format.
- Main components, functions, classes, or constants with brief technical descriptions: The JSON has a root object with `success`, `project_structure`, `statistics`, and `processing_summary`. The `project_structure` object contains arrays for `milestones`, `test_plans`, `test_suites` (which themselves contain nested `test_cases`), a flat list of all `test_cases`, and `test_runs`. Each test case object is detailed, with fields like `title`, `description`, `preconditions`, `steps`, `expected_results`, `priority`, and `type`. The `statistics` object provides a summary, including counts of processed chunks, total generated entities, and distributions of test case priority and type. The `processing_summary` includes details about the chunking process.
- Important interactions or dependencies with other files or modules: This file's structure is the target output for the `aggregate-chunks` endpoint in `app/api/ai_routes.py` and the `EnhancedChunkProcessor` service. It is used as a mock response in `ai_routes.py` when `MOCK_MODE` is enabled.
- Notable implementation details, architectural patterns, or non-trivial techniques: The structure is hierarchical, with test cases nested inside test suites, demonstrating how the AI organizes the generated tests. It also includes a flat `test_cases` list, which could be for easier top-level access to all generated cases.
- Special configurations, assets, or third-party libraries if present: This is a static JSON data file.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/ai_prompts.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/ai_prompts.json
- Purpose or role in the project: This JSON file stores the prompt templates used for interacting with Large Language Models (LLMs) for various AI-powered features. Centralizing prompts in a configuration file makes them easier to manage, version, and fine-tune.
- Main components, functions, classes, or constants with brief technical descriptions: The file contains a main JSON object with keys corresponding to different AI tasks. `chunk_processing` contains the `combined_prompt` for generating test cases from a single chunk of code. This prompt is highly detailed, instructing the AI on its role, the required output format (strict JSON), formatting rules (no newlines in strings, use of escaped characters), quality requirements, and provides a correct JSON example. `chunk_processing_old` seems to be a previous version of the prompt. `aggregate_deduplication` contains a prompt for deduplicating and organizing test cases from multiple chunks into a project structure (suites, plans, milestones). `test_case_healing` provides prompts for improving an existing test case based on user feedback, including a `system_prompt` and a `combined_prompt` that takes project context, user request, and the current test case as input.
- Important interactions or dependencies with other files or modules: These prompts are loaded and used by the `EnhancedChunkProcessor` in `app/services/chunk_processor.py` and the AI routes in `app/api/ai_routes.py`. The prompts use placeholders like `{project_name}` and `{chunk_content}` which are formatted with actual data before being sent to the AI.
- Notable implementation details, architectural patterns, or non-trivial techniques: The prompts are an example of advanced prompt engineering. The `chunk_processing` prompt is particularly detailed in its JSON formatting requirements, including rules about escaping characters and wrapping the final output in markdown code blocks. This is a technique to improve the reliability of getting valid JSON from LLMs.
- Special configurations, assets, or third-party libraries if present: This is a configuration asset for the application's AI services.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/__init__.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/__init__.py
- Purpose or role in the project: This is a standard Python package initializer file. Its presence makes the `api` directory a Python package, allowing modules within it to be imported.
- Main components, functions, classes, or constants with brief technical descriptions: The file contains a comment indicating that the main router is defined in `routes.py`.
- Important interactions or dependencies with other files or modules: This file enables the structure of the API routing system where `app/api/routes.py` can import all the individual route modules.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard convention in Python application structure.
- Special configurations, assets, or third-party libraries if present: None.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/activity_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/activity_routes.py
- Purpose or role in the project: This file defines the FastAPI API endpoints for retrieving activity logs related to a specific test case.
- Main components, functions, classes, or constants with brief technical descriptions: It contains a single endpoint defined with an `APIRouter`.
- `get_test_case_activities` (GET `/test-cases/{case_id}/activities`): This asynchronous function retrieves a paginated list of activities for a given `case_id`. It accepts `skip` and `limit` query parameters for pagination. It depends on `get_db` for a database session and `get_current_active_user` for authentication. It first checks if the test case exists. Then, it queries for `TestCaseActivity` records, using `joinedload(TestCaseActivity.created_by)` to eagerly load the associated user and prevent N+1 query problems. The response is a dictionary containing the list of `items` and pagination metadata (`total`, `page`, `pages`, `limit`).
- Important interactions or dependencies with other files or modules: It uses SQLAlchemy for database queries, interacting with the `TestCase` and `TestCaseActivity` models. It uses the `get_db` session dependency and `get_current_active_user` auth dependency. It returns data structured according to the `TestCaseActivityResponse` Pydantic schema.
- Notable implementation details, architectural patterns, or non-trivial techniques: The endpoint explicitly addresses the N+1 query problem by using SQLAlchemy's `options(joinedload(...))`. This is a crucial performance optimization. It also implements standard offset-based pagination by querying for a slice of data (`.offset(skip).limit(limit)`) and then running a separate `count` query to get the total number of records for calculating page metadata.
- Special configurations, assets, or third-party libraries if present: Depends on FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_routes.py
- Purpose or role in the project: This file defines the FastAPI API endpoints for all AI-powered features, including project creation from ZIP files, token estimation, chunk-based processing, and test case healing.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines an `APIRouter` with numerous endpoints.
- New AI-Powered Endpoints:
  - `test_form_data` (POST `/test-form-data`): A debug endpoint to verify `multipart/form-data` parsing with a zip file and JSON data.
  - `debug_zip_contents` (POST `/debug-zip-contents`): Another debug endpoint that processes a zip file using `ZipProcessor` and returns statistics about its contents.
  - `estimate_zip_tokens` (POST `/estimate-zip-tokens`): An older endpoint for token estimation, now likely superseded.
  - `estimate_tokens` (POST `/estimate-tokens`): Accepts compiled text content and AI model info to provide a detailed token and cost estimation using `TokenManager` and `PricingManager`. It also checks against model context window limits.
  - `test_chunking` (POST `/test-chunking`): A debug endpoint to test the `EnhancedChunkProcessor`'s chunking logic with sample data.
  - `prepare_chunks` (POST `/prepare-chunks`): Takes code content and model info, uses `EnhancedChunkProcessor` to determine if chunking is needed, and if so, returns the content split into chunks with overlap.
  - `process-chunk` (POST `/process-chunk`): Processes a single chunk of code using the specified AI provider (via `UnifiedAIClient`) to generate test cases. It handles loading API keys from environment variables if not provided.
  - `aggregate-chunks` (POST `/aggregate-chunks`): Takes the results from multiple processed chunks and uses an AI call (via `EnhancedChunkProcessor`) to deduplicate and organize them into a final project structure.
  - `heal-test-case` (POST `/heal-test-case`): Takes a test case ID and user feedback, uses an AI call to generate an improved version of the test case, and returns a diff for user review.
  - `save-healed-test-case` (POST `/save-healed-test-case`): Saves a healed test case to the database, creating a new `TestCaseVersion` of the old state first.
  - `restore-aggregate-version` (POST `/projects/{project_id}/restore-aggregate-version/{version_number}`): Reverts a project's `ai_aggregate_response` to a previously saved version.
  - `get_aggregate_versions` & `create_aggregate_version`: Endpoints for managing versions of a project's AI-generated structure.
- Original AI Endpoints: The file also contains older, more generic endpoints for creating/managing `AIProvider` configurations and `AIAnalysis` records.
- Important interactions or dependencies with other files or modules: This file is a central hub for AI services. It interacts heavily with services like `ZipProcessor`, `EnhancedChunkProcessor`, `UnifiedAIClient`, `TokenManager`, and `PricingManager`. It uses Pydantic schemas for request/response validation and SQLAlchemy models for database interaction.
- Notable implementation details, architectural patterns, or non-trivial techniques: The chunking workflow (`prepare-chunks`, `process-chunk`, `aggregate-chunks`) is a key architectural pattern for handling large codebases that exceed an AI model's context window. The `heal-test-case` and versioning endpoints (`save-healed-test-case`, `restore-aggregate-version`) implement a system for iterative improvement and rollback of AI-generated content. API keys are handled securely by preferring server-side environment variables over client-sent keys.
- Special configurations, assets, or third-party libraries if present: Depends on FastAPI, SQLAlchemy, and various custom AI service modules within the project. It uses a `MOCK_MODE` flag for development.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_routes_temp.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_routes_temp.py
- Purpose or role in the project: This file appears to be a temporary or backup version of `ai_routes.py`. Its content is very similar, defining endpoints for AI-powered features.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines an `APIRouter` with endpoints for AI functionalities like `test-form-data`, `debug-zip-contents`, `estimate-zip-tokens`, `estimate-tokens`, `test-chunking`, `prepare-chunks`, `process-chunk`, `aggregate-chunks`, and `heal-test-case`. It also includes the original AI provider management endpoints. The structure and logic are almost identical to the main `ai_routes.py`, but there might be minor differences or code at different stages of development. For instance, the `heal-test-case` endpoint is present but appears to be incomplete or a placeholder at the end of the file.
- Important interactions or dependencies with other files or modules: Like `ai_routes.py`, this file interacts with AI service modules (`ZipProcessor`, `EnhancedChunkProcessor`, etc.), Pydantic schemas, and SQLAlchemy models.
- Notable implementation details, architectural patterns, or non-trivial techniques: The presence of this file suggests a development workflow where files are copied before major changes, or it could be an uncommitted/temporary file that was accidentally included. Its content is largely redundant with `ai_routes.py`.
- Special configurations, assets, or third-party libraries if present: Same as `ai_routes.py`.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_settings_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/ai_settings_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing user-specific AI settings, such as which AI provider and model to use by default, and for configuring API keys.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_ai_providers` (GET `/providers`): Retrieves all AI provider configurations for the current user from the `AIProviderConfiguration` table, indicating which are configured and active.
- `get_user_ai_settings` (GET `/global-settings`): Fetches the user's default provider and model preferences. It's named `global-settings` for backward compatibility. It determines the default provider based on the `is_active` flag in the user's configurations.
- `update_user_ai_settings` (PUT `/global-settings`): Updates the user's default AI provider and model. It deactivates all other provider configurations for the user and activates the selected one.
- `configure_provider` (POST `/configure-provider`): Saves or updates an API key and other settings for a specific provider for the current user.
- Other endpoints (`get_model_capabilities`, `test_ai_provider_connection`, `get_prompt_templates`): These are mock endpoints that return hardcoded data about model capabilities and prompt templates. They do not perform live checks.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `User` and `AIProviderConfiguration` SQLAlchemy models. They use the `get_current_active_user` dependency for authentication. The `get_default_model` helper function provides fallback model names.
- Notable implementation details, architectural patterns, or non-trivial techniques: The design separates the concept of available providers from a user's specific configuration for them. The `update_user_ai_settings` endpoint ensures only one provider can be active at a time for a user by deactivating all others before activating the new default. This simplifies logic elsewhere in the application.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/apply_recommendations_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/apply_recommendations_routes.py
- Purpose or role in the project: This file defines API endpoints for applying AI-generated recommendations, such as creating or updating test cases based on an AI analysis.
- Main components, functions, classes, or constants with brief technical descriptions:
- `apply_analysis_recommendations` (POST `/apply/{analysis_id}`): The main endpoint that takes an `analysis_id` and a list of selected recommendation IDs. It iterates through the selected recommendations from the `AIAnalysis` record and calls helper functions to apply each one.
- Helper functions (`apply_single_recommendation`, `apply_test_case_creation`, `apply_test_case_update`, etc.): These functions contain the logic for specific recommendation types. For example, `apply_test_case_creation` creates a new `TestCase` record in the database based on the data provided in the recommendation.
- `get_analysis_recommendations` (GET `/analysis/{analysis_id}/recommendations`): Retrieves the recommendations stored in an `AIAnalysis` record.
- Important interactions or dependencies with other files or modules: The endpoints interact heavily with the `AIAnalysis` model to retrieve recommendations and the `TestCase`, `TestSuite` models to create or update entities. It uses `require_permission` for authorization.
- Notable implementation details, architectural patterns, or non-trivial techniques: The system uses a dispatcher pattern in `apply_single_recommendation`, which routes a recommendation to the correct handler function based on its `type` property. This makes the system extensible to new recommendation types. The application of recommendations is logged back into the `metadata` field of the `AIAnalysis` record for auditing.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/attachments_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/attachments_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing file attachments associated with test cases.
- Main components, functions, classes, or constants with brief technical descriptions:
- `ALLOWED_EXTENSIONS`: A set of allowed file extensions for uploads.
- `UPLOAD_ROOT`: A `pathlib.Path` object defining the root directory for uploads (`uploads/test_cases`).
- `get_attachments` (GET `/{case_id}/attachments`): Lists all attachment files for a given test case.
- `upload_attachments` (POST `/{case_id}/attachments`): Handles multipart file uploads. It validates file extensions, creates a unique filename to avoid collisions, saves the file to a structured directory path (`project_{id}/case_{id}`), and creates a `TestCaseActivity` log for each uploaded file.
- `download_attachment` (GET `/{case_id}/attachments/{filename}`): Serves a specific attachment file for download using `FileResponse`. It includes a security check to prevent directory traversal attacks.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestCase` model to verify existence and get the `project_id`. They create `TestCaseActivity` records upon successful upload. The routes are prefixed with `/test-cases` and are included in `routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The file storage structure is organized by project and then by case (`uploads/test_cases/project_{id}/case_{id}`), which is a scalable approach. Filenames are made unique by appending a timestamp, preventing overwrites. The download endpoint performs a path resolution check (`str(filepath.resolve()).startswith(str(folder.resolve()))`) to ensure that the requested file is within the intended directory, which is a critical security measure against path traversal vulnerabilities.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI for handling file uploads (`UploadFile`) and responses (`FileResponse`). It uses standard Python libraries `pathlib`, `shutil`, and `time`.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/authentication.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/authentication.py
- Purpose or role in the project: This file defines the API endpoints for user authentication, including registration, login, token refreshing, and logout.
- Main components, functions, classes, or constants with brief technical descriptions:
- `register` (POST `/register`): Creates a new user in the database. It checks if the email already exists and hashes the password using `get_password_hash` before saving.
- `login` (POST `/login`): Authenticates a user with an email and password. It verifies the password using `verify_password`, checks if the user is active, and if successful, generates a new JWT access token and refresh token using `create_access_token` and `create_refresh_token`. The new refresh token is stored in the `refresh_tokens` database table.
- `refresh_token` (POST `/refresh`): Takes a valid refresh token, verifies it using `verify_refresh_token`, revokes the old refresh token, and issues a new pair of access and refresh tokens.
- `logout` (POST `/logout`): Revokes a specific refresh token, effectively logging the user out from that session.
- `get_current_user_info` (GET `/me`): A protected endpoint that uses the `get_current_user` dependency to return the profile of the currently authenticated user.
- Important interactions or dependencies with other files or modules: This file is the core of the authentication system. It interacts with the `User` and `RefreshToken` models. It relies heavily on functions from `app.auth.security` for password hashing and token creation/verification, and on dependencies from `app.auth.deps` for protecting endpoints and validating tokens.
- Notable implementation details, architectural patterns, or non-trivial techniques: The authentication mechanism is a standard JWT-based system with refresh tokens for long-lived sessions. Storing refresh tokens in the database and revoking them on use or logout provides an extra layer of security, allowing sessions to be invalidated server-side.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI's security utilities (`HTTPBearer`), the `jose` library for JWTs, and `passlib`/`bcrypt` for password hashing.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/case_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/case_routes.py
- Purpose or role in the project: This file defines the API endpoints for CRUD (Create, Read, Update, Delete) operations on test cases, as well as managing test case versions.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_test_cases` (GET `/`): Retrieves a paginated list of test cases with filtering by `project_id`, `suite_id`, or `milestone_id`. It also calculates and returns statistics for the filtered dataset. It uses `joinedload` to prevent N+1 queries for the `assigned_to` user.
- `create_test_case` (POST `/`): Creates a new test case. It automatically assigns the next available `case_number` within the project. It also creates the initial `TestCaseVersion` and a `TestCaseActivity` log entry.
- `read_test_case` (GET `/{case_id}`): Retrieves a single test case by its ID.
- `update_test_case` (PUT `/{case_id}`): Updates an existing test case. If core content fields (like title, steps) are changed, it creates a new `TestCaseVersion` to track the history of changes.
- `delete_test_case` (DELETE `/{case_id}`): Deletes a test case and its dependent records (executions, versions, etc.) to avoid foreign key constraint violations.
- Versioning endpoints: `get_test_case_versions`, `get_test_case_version`, and `restore_test_case_version` provide functionality to list, view, and revert a test case to a previous version. The restore endpoint creates a backup version before reverting.
- Important interactions or dependencies with other files or modules: These endpoints interact with `TestCase`, `TestSuite`, `TestCaseVersion`, and `TestCaseActivity` models. They use `require_permission` for authorization.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `update_test_case` endpoint implements a versioning system. It tracks changes to specific fields and creates a historical `TestCaseVersion` record only when necessary. The `delete_test_case` function shows careful handling of database dependencies, deleting related child records before deleting the parent `TestCase`. The `get_test_cases` endpoint demonstrates an N+1 query fix with `joinedload`. The automatic `case_number` generation is a good example of business logic within an API endpoint.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/comment_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/comment_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing comments on test cases.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_test_case_comments` (GET `/test-cases/{case_id}/comments`): Retrieves a paginated list of comments for a specific test case. It uses `joinedload` to eagerly load the author of each comment, preventing N+1 queries.
- `create_test_case_comment` (POST `/test-cases/{case_id}/comments`): Adds a new comment to a test case and logs a `COMMENTED` activity in the `TestCaseActivity` table.
- `update_test_case_comment` (PUT `/test-cases/{case_id}/comments/{comment_id}`): Updates an existing comment. It includes an authorization check to ensure only the creator of the comment can update it.
- `delete_test_case_comment` (DELETE `/test-cases/{case_id}/comments/{comment_id}`): Deletes a comment, also with an authorization check.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestCase`, `TestCaseComment`, and `TestCaseActivity` models. They depend on `get_current_active_user` for authentication.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `get_test_case_comments` endpoint uses `joinedload` for performance optimization. The update and delete endpoints implement simple ownership-based authorization by checking `comment.created_by_id == current_user.id`. Creating a `TestCaseActivity` log entry upon comment creation provides a good audit trail.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/custom_field_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/custom_field_routes.py
- Purpose or role in the project: This file defines API endpoints for managing custom fields and their values, allowing for schema extension on entities like test cases.
- Main components, functions, classes, or constants with brief technical descriptions:
- Custom Field Management: `create_custom_field`, `get_custom_fields`, `get_custom_field`, `update_custom_field`, `delete_custom_field` provide full CRUD operations for `CustomField` definitions. Creation and updates include validation, such as ensuring select-type fields have options defined.
- Custom Field Value Management: `set_custom_field_value` creates or updates the value of a custom field for a specific entity (e.g., test case ID 123). `get_custom_field_value` retrieves a single value. `get_entity_custom_field_values` retrieves all custom field definitions and their corresponding values for a given entity type and ID.
- `validate_field_value`: A helper function that performs server-side validation of a custom field's value based on its defined type (`text`, `number`, `select`, etc.) and whether it's required.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `CustomField` and `CustomFieldValue` models. Authorization is handled via `require_permission`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This API implements a flexible custom field system. Storing values in a separate `CustomFieldValue` table with `entity_type` and `entity_id` columns is a common and scalable pattern for this feature. The `value` column is of type `JSON`, allowing it to store different data types (string, number, boolean, list for multi-select) in a single column.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/dashboard_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/dashboard_routes.py
- Purpose or role in the project: This file defines API endpoints that provide aggregated data and statistics for display on the main dashboard and project analytics pages.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_dashboard_stats` (GET `/stats`): A comprehensive endpoint that calculates and returns various statistics. This includes total counts of projects, test cases, and test runs; a breakdown of test execution statuses; a list of recent activities (new projects, cases, runs); and a "project health" summary for several projects, which includes test case counts and pass rates.
- `get_project_analytics` (GET `/project-analytics/{project_id}`): Provides time-series data for a specific project over a given number of days. It calculates trends for test case creation and test execution statuses, as well as current distributions of test cases by priority and type.
- `get_execution_report` (GET `/execution-report/{run_id}`): Generates a detailed report for a single test run, including status counts, completion percentage, pass rate, and a list of all individual execution results.
- Important interactions or dependencies with other files or modules: These endpoints perform complex aggregation queries across multiple SQLAlchemy models (`Project`, `TestCase`, `TestRun`, `TestExecution`, etc.). They use `get_current_active_user` for authentication.
- Notable implementation details, architectural patterns, or non-trivial techniques: The endpoints make extensive use of SQLAlchemy's aggregation functions like `func.count()` and grouping with `group_by()`. The `get_dashboard_stats` endpoint demonstrates how to build a complex data object for a dashboard by combining results from multiple independent queries. The `get_project_analytics` endpoint shows how to generate data suitable for time-series charts by grouping results by date (`func.date(Model.created_at)`).
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/defect_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/defect_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing defects linked to test cases.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_test_case_defects` (GET `/test-cases/{case_id}/defects`): Retrieves a paginated list of defects for a specific test case. It uses `joinedload` to eagerly load the user who created the defect, preventing N+1 queries.
- `create_test_case_defect` (POST `/test-cases/{case_id}/defects`): Creates a new defect associated with a test case. It accepts a `test_run_id` to link the defect to a specific execution. It also creates a `TestCaseActivity` log entry of type `DEFECT_ADDED`.
- `update_test_case_defect` (PUT `/test-cases/{case_id}/defects/{defect_id}`): Updates an existing defect's status, comment, or assignee. It logs a `DEFECT_UPDATED` activity.
- `delete_test_case_defect` (DELETE `/test-cases/{case_id}/defects/{defect_id}`): Deletes a defect from a test case.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestCase`, `TestCaseDefect`, and `TestCaseActivity` models. They depend on `get_current_active_user` for authentication. The response is shaped by the `TestCaseDefectResponse` Pydantic schema.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of `joinedload` is a key performance optimization. The system logs defect creation and updates as activities, providing a clear audit trail for the associated test case. Linking defects to a `test_run_id` is a crucial feature for traceability in test management.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/milestone_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/milestone_routes.py
- Purpose or role in the project: This file defines the API endpoints for CRUD operations on project milestones.
- Main components, functions, classes, or constants with brief technical descriptions:
- `read_milestones` (GET `/`): Retrieves a list of all milestones, with an optional filter by `project_id`.
- `create_milestone` (POST `/`): Creates a new milestone for a given project.
- `read_milestone` (GET `/{milestone_id}`): Retrieves a single milestone by its ID.
- `update_milestone` (PUT `/{milestone_id}`): Updates the details of an existing milestone.
- `delete_milestone` (DELETE `/{milestone_id}`): Deletes a milestone, but only if it is not currently referenced by any test cases or test runs.
- `get_milestone_test_cases` and `get_milestone_test_runs`: Endpoints to retrieve all test cases or test runs associated with a specific milestone.
- `check_milestone_access`: A helper function for authorization, ensuring the user has the required permission for the action.
- Important interactions or dependencies with other files or modules: The endpoints interact with the `Milestone`, `Project`, `TestCase`, and `TestRun` models. Authorization is handled by `require_permission` and the custom `check_milestone_access` function.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `delete_milestone` endpoint includes a business logic check to prevent the deletion of milestones that are in use. This referential integrity check at the API level provides a user-friendly error message rather than a generic database constraint violation error.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/project_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/project_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing projects and project members.
- Main components, functions, classes, or constants with brief technical descriptions:
- `read_projects` (GET `/`): Retrieves a list of projects accessible to the current user. Admins see all projects; other users see projects they created or are members of.
- `read_projects_with_stats` (GET `/with-stats`): Similar to `read_projects` but enriches each project with statistics like test case counts, run counts, milestone progress, and a "health percentage" based on test pass rates.
- `create_project` (POST `/`): Creates a new project. It automatically adds the creator as an "owner" member and can add other participants by email if provided.
- `read_project`, `update_project`, `rename_project`: Standard endpoints for retrieving and modifying a single project.
- `delete_project` (DELETE `/{project_id}`): Deletes a project and all its associated data (milestones, suites, cases, runs, etc.). It performs deletions in the correct order to respect foreign key constraints.
- Member Management Endpoints: `get_project_members`, `add_project_member`, `remove_project_member` provide functionality to manage user access to a project.
- `check_project_access`: A key authorization helper function that verifies if a user has permission to access a project, checking for admin status, creator status, or member status.
- Important interactions or dependencies with other files or modules: This file has extensive dependencies, as deleting a project requires cleaning up almost every other type of entity in the database. It interacts with `Project`, `ProjectMember`, and numerous other models.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `delete_project` endpoint is a complex transaction that demonstrates careful handling of database dependencies to perform a cascading delete via the application logic. The `read_projects_with_stats` endpoint shows how to aggregate data from multiple tables to build a rich summary object. The authorization logic in `check_project_access` correctly implements a multi-level access control system (admin, creator, member).
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing repository configurations and viewing integration logs related to the self-healing test case feature.
- Main components, functions, classes, or constants with brief technical descriptions:
- `create_repository` (POST `/`): A simplified endpoint for creating a `RepositoryConfig`. It includes logic to automatically extract the repository name from a GitHub URL.
- `get_repositories` (GET `/`): A simplified endpoint for listing repository configurations, with optional filtering by `project_id`. It masks sensitive data like access tokens and webhook secrets in the response.
- CRUD endpoints for `/configs/`: `create_repository_config`, `get_repository_configs`, `get_repository_config`, `update_repository_config`, and `delete_repository_config` provide full administrative control over `RepositoryConfig` entities.
- `get_integration_logs` (GET `/integration-logs`): Retrieves `IntegrationLog` records, allowing filtering by repository, event type, or success status.
- Important interactions or dependencies with other files or modules: These endpoints perform CRUD operations on the `RepositoryConfig`, `PRAnalysis`, `TestCaseDelta`, and `IntegrationLog` models. The webhook endpoints interact with the `GitHubIntegrationService`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The API provides both simplified endpoints (`/`) for basic frontend use and more detailed administrative endpoints (`/configs/`). The GET endpoints demonstrate a security best practice by masking sensitive information (`access_token`, `webhook_secret`) before sending the response to the client. The `create_repository` endpoint includes helpful business logic to parse the repository name from the URL.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes_backup.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes_backup.py
- Purpose or role in the project: This file is a backup of the repository integration routes. Its content is largely identical to `repository_routes.py` but also includes webhook handling logic that appears to have been moved to `webhook_routes.py` in the final structure.
- Main components, functions, classes, or constants with brief technical descriptions: It contains CRUD endpoints for `RepositoryConfig` and `PRAnalysis`. Crucially, it also includes webhook endpoints (`/webhooks/github/{config_id}`, `/webhooks/gitlab/{config_id}`) and helper functions (`verify_github_signature`, `handle_github_pr_event`, etc.) for processing incoming events from GitHub and GitLab. It also has endpoints for managing `TestCaseDelta` entities, such as applying AI-suggested changes.
- Important interactions or dependencies with other files or modules: This file shows a more integrated version of repository and webhook logic. It interacts with `RepositoryConfig`, `PRAnalysis`, `TestCaseDelta`, and `IntegrationLog` models. It uses `GitHubIntegrationService` for processing PRs.
- Notable implementation details, architectural patterns, or non-trivial techniques: The webhook endpoints demonstrate how to handle external service callbacks. `verify_github_signature` uses `hmac` and `hashlib` to validate the payload's integrity and authenticity using a shared secret, a critical security measure for webhooks. The webhook handlers are designed to be asynchronous and can trigger background tasks for long-running analyses. The presence of this file suggests a refactoring where webhook logic was separated into its own `webhook_routes.py` file.
- Special configurations, assets, or third-party libraries if present: Uses `hmac` and `hashlib` for webhook security. Depends on FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes_fixed.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/repository_routes_fixed.py
- Purpose or role in the project: This file appears to be another version or backup of the repository routes, likely from a point in development after a fix or change. Its content is identical to `repository_routes.py`.
- Main components, functions, classes, or constants with brief technical descriptions: It defines CRUD endpoints for `RepositoryConfig` and an endpoint to get `IntegrationLog` records. It includes the simplified (`/`) and administrative (`/configs/`) endpoints for managing repository configurations. Sensitive data is masked in GET responses.
- Important interactions or dependencies with other files or modules: Interacts with the `RepositoryConfig` and `IntegrationLog` models.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file is redundant with `repository_routes.py`, indicating it might be a remnant of a version control merge or a manual backup.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/routes.py
- Purpose or role in the project: This file serves as the main API router for the FastAPI application. It aggregates all the individual route modules from the `api` package into a single router.
- Main components, functions, classes, or constants with brief technical descriptions: It creates an instance of `APIRouter`. It then uses `api_router.include_router()` to mount the routers from all other route modules (`authentication`, `user_routes`, `project_routes`, `case_routes`, `ai_routes`, etc.). Each included router is given a `prefix` (e.g., `/auth`, `/users`) and a `tags` value, which helps organize the endpoints in the auto-generated OpenAPI (Swagger) documentation. It also defines a root health check endpoint at `/health`.
- Important interactions or dependencies with other files or modules: This file is the central point of the API's routing structure. It imports all other router modules within the `app.api` package. This main `api_router` is then included by the main FastAPI application instance in `app/main.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file demonstrates a standard and clean way to organize a large FastAPI application. By breaking down endpoints into logical modules and then combining them in a single place, the codebase remains modular and maintainable.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI's `APIRouter`.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/run_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/run_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing test runs and test executions.
- Main components, functions, classes, or constants with brief technical descriptions:
- Test Run Endpoints: Includes CRUD operations for test runs (`read_test_runs`, `create_test_run`, `read_test_run`, `update_test_run`, `delete_test_run`). There is also an endpoint `create_run_from_plan` to create a new test run based on an existing test plan.
- Test Execution Endpoints: Endpoints for managing the relationship between test runs and test cases. `get_run_test_cases` lists all test executions for a run. `create_test_execution` adds a test case to a run.
- Test Result Endpoints (`/{run_id}/results/{case_id}`): These endpoints are aliases for managing `TestExecution` records but are structured for the frontend's use case of submitting results. `create_test_run_result` and `update_test_run_result` are the main endpoints for testers to submit the status (`passed`, `failed`, etc.) and details of a test. They also handle the creation of a `TestCaseDefect` if a test fails and defect information is provided.
- `get_all_test_run_results`: A paginated endpoint to get all execution results for a run, which uses `joinedload` for performance.
- Important interactions or dependencies with other files or modules: Interacts with `TestRun`, `TestExecution`, `TestCase`, `TestCaseActivity`, and `TestCaseDefect` models. It uses the `TestExecutionStatus` enum.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `create_test_run_result` and `update_test_run_result` endpoints contain significant business logic. They not only update the execution status but also create corresponding activity logs and defects, ensuring data integrity and a complete audit trail. The use of `joinedload(TestExecution.executed_by)` in `get_all_test_run_results` is a performance optimization to prevent N+1 queries.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/suite_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/suite_routes.py
- Purpose or role in the project: This file defines the API endpoints for CRUD operations on test suites.
- Main components, functions, classes, or constants with brief technical descriptions:
- `read_test_suites` (GET `/`): Retrieves a list of all test suites, with an optional filter by `project_id`.
- `read_test_suites_by_project` (GET `/by-project/{project_id}`): A specific endpoint to get all suites belonging to a project.
- `create_test_suite` (POST `/`): Creates a new test suite within a project.
- `read_test_suite` (GET `/{suite_id}`): Retrieves a single test suite by its ID.
- `update_test_suite` (PUT `/{suite_id}`): Updates the name or description of an existing test suite.
- `delete_test_suite` (DELETE `/{suite_id}`): Deletes a test suite.
- `check_suite_access`: A helper function for authorization.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestSuite` and `Project` models. They use `require_permission` for authorization.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard set of CRUD endpoints. The `delete_test_suite` endpoint does not appear to handle cascading deletes of associated test cases, which could lead to orphaned records or database constraint violations if not handled elsewhere.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/test_delta_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/test_delta_routes.py
- Purpose or role in the project: This file defines API endpoints related to versioning and comparing test cases. "Delta" here refers to the difference between versions.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_test_case_versions` (GET `/test-case/{case_id}/versions`): Retrieves all historical versions of a specific test case from the `TestCaseVersion` table.
- `compare_test_case_versions` (GET `/test-case/{case_id}/compare`): Takes two version numbers as query parameters and generates a unified diff for various fields (`title`, `description`, `steps`, etc.) between the two versions using Python's `difflib`.
- `get_version_delta` (GET `/test-case/{case_id}/delta/{version_number}`): Compares a specific version against its immediate predecessor (version - 1) and returns an object showing which fields have changed, along with their old and new values.
- `get_recent_test_case_changes` (GET `/project/{project_id}/recent-changes`): Retrieves a list of recent `TestCaseVersion` records for a given project within a specified time frame (default 7 days).
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestCase` and `TestCaseVersion` models.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `compare_test_case_versions` endpoint's use of the `difflib` library to generate a standard "diff" output is a nice feature for visualizing changes between versions, similar to what version control systems like Git provide. This provides a powerful UI/UX capability for tracking the history of a test case.
- Special configurations, assets, or third-party libraries if present: Uses Python's built-in `difflib` library. Depends on FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/test_plan_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/test_plan_routes.py
- Purpose or role in the project: This file defines the API endpoints for managing test plans and the items (test cases) within them.
- Main components, functions, classes, or constants with brief technical descriptions:
- Test Plan CRUD: `create_test_plan`, `get_test_plans`, `get_test_plan`, `update_test_plan`, and `delete_test_plan` provide full management of `TestPlan` entities.
- Test Plan Item Management: `add_test_case_to_plan` adds a single test case to a plan. `get_plan_items` lists all cases in a plan. `update_plan_item` modifies an item (e.g., its order). `remove_test_case_from_plan` removes a case from a plan.
- Bulk Operations: `bulk_add_test_cases_to_plan` adds multiple test cases to a plan in a single API call, checking for duplicates. `reorder_plan_items` updates the `order_index` for multiple items at once.
- Important interactions or dependencies with other files or modules: These endpoints interact with the `TestPlan`, `TestPlanItem`, `TestCase`, and `Project` models. They use `require_permission` for authorization.
- Notable implementation details, architectural patterns, or non-trivial techniques: The API supports both individual and bulk operations for managing test plan contents, which is efficient for the frontend. The `bulk_add` endpoint demonstrates checking for existing items to prevent duplicates. The `reorder_plan_items` endpoint allows for efficient reordering of items in a single transaction.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/user_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/user_routes.py
- Purpose or role in the project: This file defines the API endpoints for user management, including profile updates for the current user and administrative CRUD operations for all users.
- Main components, functions, classes, or constants with brief technical descriptions:
- Current User (`/me`) Endpoints: `read_users_me` retrieves the current user's profile. `update_users_me` allows a user to update their own profile information (name, email, avatar). `update_user_theme` updates the user's theme preference ('light' or 'dark'). `change_password` allows the current user to change their password after verifying their current one.
- Admin Endpoints: `read_users` (lists all users), `create_user`, `read_user` (by ID), `update_user`, and `delete_user` are administrative endpoints protected by `require_admin` or `require_permission(Permission.MANAGE_USERS)`. The `update_user` endpoint allows an admin to change any field, including resetting a user's password.
- Important interactions or dependencies with other files or modules: The endpoints interact with the `User` model. They use authentication and authorization dependencies from `app.auth.deps`, such as `get_current_active_user` and `require_admin`. They use security functions from `app.auth.security` for password hashing and verification.
- Notable implementation details, architectural patterns, or non-trivial techniques: The API provides a clear separation between operations a user can perform on their own profile (`/me`) and administrative operations on any user (`/`). The `delete_user` endpoint includes a check to prevent an admin from deleting their own account.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI and SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/api/webhook_routes.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/api/webhook_routes.py
- Purpose or role in the project: This file defines the API endpoints that act as webhooks to receive events from external repository services like GitHub and GitLab.
- Main components, functions, classes, or constants with brief technical descriptions:
- `github_webhook` (POST `/github/{config_id}`): The endpoint for receiving GitHub webhooks. It verifies the payload signature using a shared secret, parses the event type (`X-GitHub-Event`), and delegates to a handler function like `handle_github_pr_event_enhanced`.
- `gitlab_webhook` (POST `/gitlab/{config_id}`): The endpoint for GitLab webhooks. It verifies the request using the `X-Gitlab-Token` header.
- Helper Functions: `verify_github_signature` implements the HMAC-SHA256 signature verification. `handle_github_pr_event_enhanced` contains the logic to process a pull request event: it creates or updates a `PRAnalysis` record and queues a background task (`analyze_pr_with_github_data`) to fetch PR details and run the AI analysis. `analyze_pr_with_github_data` is an async background task that uses `GitHubAPIClient` to fetch PR diff and file data, then calls `GitHubIntegrationService.analyze_pull_request`.
- Other Endpoints: `list_webhooks`, `get_webhook_details`, `test_webhook`, `get_webhook_logs`, `toggle_webhook_status`, and `get_supported_webhook_events` are administrative endpoints for managing and inspecting webhooks from the frontend.
- Important interactions or dependencies with other files or modules: These endpoints are the entry point for the self-healing test case feature. They interact with `RepositoryConfig` and `PRAnalysis` models and trigger the `GitHubIntegrationService`. The `GitHubAPIClient` (defined in `github_integration_service.py`) is used for making outbound API calls to GitHub.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of background tasks (`background_tasks.add_task`) is critical for webhook performance. It allows the webhook to return a quick 200 OK response to the provider while the long-running AI analysis happens in the background. The signature verification is essential for securing the webhook endpoints.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI's `BackgroundTasks`, and Python's `hmac` and `hashlib`.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/auth/deps.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/auth/deps.py
- Purpose or role in the project: This file contains FastAPI dependency functions used for handling authentication and authorization across the API.
- Main components, functions, classes, or constants with brief technical descriptions:
- `get_current_user`: A dependency that extracts the JWT token from the `Authorization` header, verifies it using `verify_token`, and retrieves the corresponding `User` object from the database. It raises a 401 Unauthorized HTTPException if the token is invalid or the user doesn't exist.
- `get_current_active_user`: A dependency that builds upon `get_current_user` and adds a check to ensure the user's `is_active` flag is true.
- `require_permission`: A decorator factory that creates a dependency for checking role-based permissions. It takes a `permission` string (e.g., `Permission.CREATE`) and returns a dependency function that verifies if the current user's role has that permission according to the rules in `app.core.permissions`.
- `require_role`: A similar decorator factory that requires a specific user role.
- `require_admin`: A simple dependency that ensures the current user has the `ADMIN` role.
- `verify_refresh_token`: A function (not a FastAPI dependency) used by the auth routes to validate a refresh token against the database, checking that it exists, is not revoked, and has not expired.
- Important interactions or dependencies with other files or modules: These functions are used as `Depends()` in API route definitions across the application. They rely on `verify_token` from `app.auth.security` and the permission logic from `app.core.permissions`. They query the `User` and `RefreshToken` models.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file exemplifies FastAPI's dependency injection system. By defining security logic as reusable dependencies, endpoints can declare their security requirements declaratively (e.g., `current_user: User = Depends(require_admin)`), keeping the route logic clean and focused on business tasks.
- Special configurations, assets, or third-party libraries if present: Uses FastAPI's dependency injection and security utilities (`HTTPBearer`).

FILE: testworthy-pro-dev/testworthy-pro-backend/app/auth/security.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/auth/security.py
- Purpose or role in the project: This file contains core security-related utility functions for password hashing and JWT (JSON Web Token) management.
- Main components, functions, classes, or constants with brief technical descriptions:
- `pwd_context`: An instance of `passlib.context.CryptContext` configured to use the `bcrypt` hashing algorithm.
- `verify_password`: Compares a plain-text password with a hashed password. It includes logic to handle bcrypt's 72-byte limit and uses `bcrypt.checkpw` directly for reliability, with a fallback to `pwd_context.verify`.
- `get_password_hash`: Hashes a plain-text password. It also enforces the 72-byte limit for bcrypt compatibility and uses `bcrypt.hashpw` directly, with a `passlib` fallback.
- `create_access_token` and `create_refresh_token`: Functions that generate JWTs. They take a data payload (containing the user ID), set an expiration time based on settings, add a `type` claim ('access' or 'refresh'), and sign the token using the `SECRET_KEY` and `ALGORITHM` from the application settings.
- `verify_token`: Decodes and validates a JWT. It checks the signature, expiration, and the `token_type` claim. It raises an HTTPException if validation fails.
- Important interactions or dependencies with other files or modules: These functions are used by the authentication routes (`app/api/authentication.py`) and auth dependencies (`app/auth/deps.py`). They rely on configuration values from `app.core.config.settings` (e.g., `SECRET_KEY`, `ALGORITHM`).
- Notable implementation details, architectural patterns, or non-trivial techniques: The password hashing functions explicitly handle the 72-byte input limitation of bcrypt by truncating the password bytes if necessary. This prevents errors with very long passwords. The direct use of the `bcrypt` library with a `passlib` fallback is a robust implementation detail. The use of separate token types ('access', 'refresh') encoded within the JWT payload is a good security practice.
- Special configurations, assets, or third-party libraries if present: Uses `python-jose` for JWT operations and `passlib` and `bcrypt` for password hashing.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/chunking_sample_response.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/chunking_sample_response.json
- Purpose or role in the project: This JSON file provides a sample response for the `/process-chunk` endpoint. It is used as mock data during development and testing to simulate the output of an AI processing a single chunk of code.
- Main components, functions, classes, or constants with brief technical descriptions: The JSON object has a root structure with fields like `success`, `chunk_id`, `total_chunks`, `test_cases`, `chunk_summary`, `processing_time_seconds`, `provider`, and `model`. The `test_cases` key contains an array of detailed test case objects, each with fields like `title`, `description`, `preconditions`, `steps`, `expected_results`, `priority`, `type`, and metadata like `chunk_id` and `source_lines`.
- Important interactions or dependencies with other files or modules: This file is loaded and returned by the `/process-chunk` endpoint in `app/api/ai_routes.py` when `MOCK_MODE` is enabled. Its structure defines the expected output from the `EnhancedChunkProcessor` service.
- Notable implementation details, architectural patterns, or non-trivial techniques: The sample data is comprehensive and covers various types of tests (functional, regression, security) and priorities, making it useful for testing the frontend's ability to render different kinds of test cases.
- Special configurations, assets, or third-party libraries if present: This is a static JSON data file.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/config/pricing_config.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/config/pricing_config.json
- Purpose or role in the project: This JSON file stores pricing information for various AI models from different providers (OpenAI, Anthropic, Gemini). It is used to estimate the cost of AI operations.
- Main components, functions, classes, or constants with brief technical descriptions: The file is structured as a JSON object where top-level keys are the provider names (`openai`, `anthropic`, `gemini`). Each provider object contains `provider_notes` and a `models` array. Each object in the `models` array specifies a `model` name, `description`, `input_price_per_1m_tokens`, and `output_price_per_1m_tokens`. Prices are given in USD per 1 million tokens.
- Important interactions or dependencies with other files or modules: This configuration file is loaded and used by the `PricingManager` service (`app/services/pricing_manager.py`) to calculate the estimated cost of API calls.
- Notable implementation details, architectural patterns, or non-trivial techniques: Centralizing pricing data in a configuration file allows the application to be updated with new models and pricing changes without modifying the code. This is a good example of separating configuration from application logic.
- Special configurations, assets, or third-party libraries if present: This is a static configuration file.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/core/config.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/core/config.py
- Purpose or role in the project: This file defines the configuration settings for the backend application. It uses Pydantic's `BaseSettings` to load configuration from environment variables and a `.env` file.
- Main components, functions, classes, or constants with brief technical descriptions: A `Settings` class is defined, inheriting from `BaseSettings`. It declares all the application's configuration variables with their types and default values. Key settings include: `API_V1_STR` (API prefix), `SECRET_KEY`, `ALGORITHM`, `ACCESS_TOKEN_EXPIRE_MINUTES` (for JWT), `DATABASE_URL`, API keys for various AI providers (`GEMINI_API_KEY`, `OPENAI_API_KEY`, etc.), Google Cloud settings (`GOOGLE_APPLICATION_CREDENTIALS`, `GCP_PROJECT_ID`), `ALLOWED_ORIGINS` (for CORS), and `ENVIRONMENT`. An instance of this class, `settings`, is created, which automatically loads the values.
- Important interactions or dependencies with other files or modules: The `settings` object is imported and used throughout the application wherever configuration is needed, such as in `app/main.py` for CORS, `app/database/session.py` for the database connection, and `app/auth/security.py` for JWT secrets. The `Config` nested class tells Pydantic to load settings from a file named `.env`.
- Notable implementation details, architectural patterns, or non-trivial techniques: Using `pydantic-settings` provides a robust and type-safe way to manage configuration. It automatically handles loading from environment variables or a `.env` file, providing a single source of truth for all settings. The script also includes logic to set the `GOOGLE_APPLICATION_CREDENTIALS` environment variable programmatically if it's defined in the settings, which is necessary for some Google Cloud libraries to work correctly.
- Special configurations, assets, or third-party libraries if present: Uses the `pydantic-settings` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/core/permissions.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/core/permissions.py
- Purpose or role in the project: This file defines the role-based access control (RBAC) system for the application. It specifies user roles, available permissions, and the mapping between them.
- Main components, functions, classes, or constants with brief technical descriptions:
- `UserRole`: An `Enum` defining the possible user roles: `ADMIN`, `PROJECT_MANAGER`, `QA`, `DEVELOPER`, `GUEST`.
- `Permission`: An `Enum` defining the available permissions: `CREATE`, `READ`, `UPDATE`, `DELETE`, `MANAGE_USERS`, `CONFIGURE_SETTINGS`.
- `ROLE_PERMISSIONS`: A dictionary that maps each `UserRole` to a list of `Permission`s it possesses. For example, `ADMIN` has all permissions, while `GUEST` only has `READ`.
- `has_permission`: A function that takes a user role and a permission string and returns `True` if that role has the given permission, based on the `ROLE_PERMISSIONS` mapping.
- Important interactions or dependencies with other files or modules: The `UserRole` enum is used in the `User` model. The `has_permission` function is used by the `require_permission` dependency in `app/auth/deps.py` to protect API endpoints.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file centralizes all RBAC logic. This is a clean architectural pattern that makes it easy to understand and modify permissions for different roles without searching through the entire codebase.
- Special configurations, assets, or third-party libraries if present: Uses Python's built-in `enum` module.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/database/__init__.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/database/__init__.py
- Purpose or role in the project: This is a package initializer file for the `database` directory. It makes all the SQLAlchemy models available for easy import.
- Main components, functions, classes, or constants with brief technical descriptions: The file imports `Base` from `app.database.session` and all models (`*`) from `app.database.models`.
- Important interactions or dependencies with other files or modules: This allows other parts of the application to import all database-related components from a single point, e.g., `from app.database import User, Project`. It is used by `app/main.py` to create all tables.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard Python packaging practice to simplify imports.
- Special configurations, assets, or third-party libraries if present: None.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/database/models.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/database/models.py
- Purpose or role in the project: This is a critical file that defines the entire database schema using SQLAlchemy's declarative ORM. Each class in this file corresponds to a table in the database.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines numerous classes that inherit from `Base` (the declarative base).
- Enums: Defines several Python `enum.Enum` classes (`TestCasePriority`, `TestRunStatus`, etc.) that are used for column types.
- Main Models: `User`, `Project`, `Milestone`, `TestSuite`, `TestCase`, `TestRun`, `TestExecution`. These form the core entities of the test management system.
- Supporting Models: `RefreshToken`, `ProjectMember`, `TestCaseVersion`, `TestCaseComment`, `TestCaseActivity`, `TestCaseDefect`, `CustomField`, `CustomFieldValue`, `TestPlan`, `TestPlanItem`.
- AI & Integration Models: `AIProviderConfiguration`, `AISettings`, `AIAnalysis`, `RepositoryConfig`, `PRAnalysis`, `TestCaseDelta`, `IntegrationLog`, `ProjectAggregateVersion`.
- Each model class defines a `__tablename__` and `Column` attributes for each field, specifying data types (e.g., `Integer`, `String`, `JSON`), primary keys, foreign keys, and default values. `relationship()` is used to define the connections between tables, enabling ORM features like lazy loading and joins.
- Important interactions or dependencies with other files or modules: This file is the single source of truth for the database schema. It is used by all API routes for querying and modifying data, by `app/main.py` to create tables, and by Alembic for generating migrations.
- Notable implementation details, architectural patterns, or non-trivial techniques: The models are well-structured with clear relationships. For example, `TestCase` has relationships to `TestSuite`, `Milestone`, `User` (for created_by and assigned_to), and one-to-many relationships with `versions`, `comments`, `activities`, and `defects`. The use of `SQLEnum` with `create_type=False` is a good practice for working with PostgreSQL ENUMs managed by Alembic. The file defines composite indexes using `Index()` for performance on tables like `test_cases`.
- Special configurations, assets, or third-party libraries if present: The entire file is built upon the SQLAlchemy ORM library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/database/session.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/database/session.py
- Purpose or role in the project: This file is responsible for setting up the database connection and session management for SQLAlchemy.
- Main components, functions, classes, or constants with brief technical descriptions:
- `engine`: An instance of `sqlalchemy.create_engine`, created using the `DATABASE_URL` from the application settings. This object manages the connection pool to the database.
- `SessionLocal`: A session factory created using `sessionmaker`. It's configured to not autocommit or autoflush.
- `Base`: An instance of `declarative_base()`. All ORM model classes in the application inherit from this base class.
- `get_db`: A FastAPI dependency function. It creates a new database session from `SessionLocal` for each incoming request, `yield`s it to the route handler, and then ensures the session is closed in a `finally` block, even if an error occurred.
- Important interactions or dependencies with other files or modules: It uses the `DATABASE_URL` from `app.core.config.settings`. The `Base` object is used by all models in `app.database.models.py`. The `get_db` dependency is used in almost every API route to get a database session.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `get_db` function is a standard and recommended pattern for managing database sessions per-request in FastAPI. Using `yield` within a `try...finally` block ensures that database connections are properly opened and closed for each request, preventing connection leaks.
- Special configurations, assets, or third-party libraries if present: Uses the SQLAlchemy library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/main.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/main.py
- Purpose or role in the project: This is the main entry point for the FastAPI backend application. It initializes the FastAPI app, sets up middleware, includes the API routers, and defines root and health check endpoints.
- Main components, functions, classes, or constants with brief technical descriptions:
- `models.Base.metadata.create_all(bind=engine)`: This line, executed at startup, automatically creates all database tables defined in the SQLAlchemy models if they don't already exist.
- `app = FastAPI(...)`: Creates the main FastAPI application instance with metadata like title and description.
- Middleware: It adds `GZipMiddleware` to compress API responses and `CORSMiddleware` to handle Cross-Origin Resource Sharing (allowing requests from any origin with `allow_origins=["*"]`). It also adds a custom middleware `add_process_time_header` to time each request and log slow ones.
- `app.include_router(api_router, ...)`: Includes the main API router from `app.api.routes`, prefixing all its routes with `/api/v1`.
- Root endpoints: Defines a simple `/` route and a `/health` route for health checks.
- Important interactions or dependencies with other files or modules: It imports and uses `settings` from `app.core.config`, `api_router` from `app.api.routes`, and the `engine` and `models` from the `database` package. This file is the target for the Uvicorn server, as specified in `run.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The automatic table creation is a convenient feature for development. The custom middleware for timing requests and logging slow ones is a good practice for performance monitoring. The use of GZip compression is a simple but effective performance optimization.
- Special configurations, assets, or third-party libraries if present: Built on the FastAPI framework.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/activities.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/activities.py
- Purpose or role in the project: This file defines the Pydantic schemas for test case activity data. Schemas are used for data validation, serialization, and documentation in FastAPI.
- Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseActivityBase`: The base schema defining the core fields for an activity: `activity_type`, `description`, and optional `activity_data` (a dictionary for structured metadata).
- `TestCaseActivityCreate`: A schema for creating a new activity, inheriting from the base schema.
- `TestCaseActivityResponse`: A schema for representing an activity in API responses. It extends the base schema with fields that are present in the database model, such as `id`, `test_case_id`, `created_at`, `created_by_id`, and `created_by_name`.
- `Config`: The nested class with `from_attributes = True` allows the Pydantic model to be created directly from a SQLAlchemy ORM object.
- Important interactions or dependencies with other files or modules: These schemas are used in `app/api/activity_routes.py` to define the response model for the activity listing endpoint.
- Notable implementation details, architectural patterns, or non-trivial techniques: Separating the schemas into `Base`, `Create`, and `Response` is a standard Pydantic/FastAPI pattern. It allows for different validation rules and fields for input and output data.
- Special configurations, assets, or third-party libraries if present: Uses the Pydantic library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/aggregate_version.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/aggregate_version.py
- Purpose or role in the project: This file defines the Pydantic schemas related to versioning of AI-generated project aggregate data.
- Main components, functions, classes, or constants with brief technical descriptions:
- `ProjectAggregateVersionBase`: Defines the base field `description`.
- `ProjectAggregateVersionCreate`: Inherits from base and adds `aggregate_data`, which is a dictionary, for creating a new version.
- `ProjectAggregateVersion`: The main response schema, which includes database-generated fields like `id`, `project_id`, `version_number`, and `created_at`.
- Important interactions or dependencies with other files or modules: These schemas correspond to the `ProjectAggregateVersion` SQLAlchemy model and are used in the `ai_routes.py` endpoints for managing aggregate versions.
- Notable implementation details, architectural patterns, or non-trivial techniques: This follows the standard Pydantic schema separation pattern (`Base`, `Create`, `Response`).
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/auth_schemas.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/auth_schemas.py
- Purpose or role in the project: This file defines the Pydantic schemas used specifically for authentication-related API endpoints.
- Main components, functions, classes, or constants with brief technical descriptions:
- `Token`: Defines the structure of the response after a successful login or token refresh, containing `access_token`, `refresh_token`, `token_type`, and `expires_in`.
- `TokenData`: Defines the data structure encoded within the JWT payload, typically the `user_id`.
- `LoginRequest`: Defines the expected request body for the login endpoint, requiring an `email` and `password`.
- `RefreshTokenRequest`: Defines the expected request body for the token refresh endpoint, requiring a `refresh_token`.
- Important interactions or dependencies with other files or modules: These schemas are used as request bodies and response models in `app/api/authentication.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard set of schemas for implementing a JWT-based authentication flow with refresh tokens.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/comments.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/comments.py
- Purpose or role in the project: This file defines the Pydantic schemas for test case comments.
- Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseCommentBase`: The base schema with a single `content` field.
- `TestCaseCommentCreate`: Schema for creating a new comment.
- `TestCaseCommentUpdate`: Schema for updating a comment.
- `TestCaseCommentResponse`: The response schema, including fields like `id`, `test_case_id`, timestamps, and author information (`created_by_id`, `created_by_name`).
- Important interactions or dependencies with other files or modules: These schemas are used in the API endpoints defined in `app/api/comment_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: Follows the standard Pydantic schema separation pattern.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/defects.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/defects.py
- Purpose or role in the project: This file defines the Pydantic schemas for defects associated with test cases.
- Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseDefectBase`: The base schema defining fields for a defect, such as `defect_type` (e.g., 'Jira'), `defect_id` (external ID), `test_status`, and `comment`.
- `TestCaseDefectCreate`: Inherits from base and adds an optional `test_run_id` for linking the defect to a specific test execution.
- `TestCaseDefectUpdate`: Defines the fields that can be updated, such as `status`, `comment`, and `assigned_to`.
- `TestCaseDefectResponse`: The schema for API responses, including all database fields and the creator's name.
- Important interactions or dependencies with other files or modules: These schemas are used by the endpoints in `app/api/defect_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The schema design allows linking defects to both a test case and an optional test run, which is important for traceability.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/extended.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/extended.py
- Purpose or role in the project: This file contains a collection of Pydantic schemas for various "extended" features of the application, such as custom fields, AI providers, repository integration, and dashboard statistics.
- Main components, functions, classes, or constants with brief technical descriptions:
- Custom Field Schemas: `CustomFieldCreate`, `CustomFieldUpdate`, `CustomField` define the structure for creating, updating, and representing custom fields. `CustomFieldValue` schemas handle the data for these fields.
- AI Provider & Analysis Schemas: `AIProviderCreate`, `AIProviderUpdate`, `AIAnalysisCreate`, etc., define the data structures for managing AI configurations and analysis jobs.
- Dashboard Schemas: `DashboardStats` defines the complex data structure returned by the main dashboard endpoint.
- Repository Integration Schemas: `RepositoryConfigCreate`, `PRAnalysisCreate`, `TestCaseDeltaSchema`, `IntegrationLogSchema` define the data structures for the self-healing test case feature, including repository configurations, pull request analyses, suggested test changes (deltas), and logs.
- Important interactions or dependencies with other files or modules: These schemas are used across multiple API route files, including `custom_field_routes.py`, `ai_routes.py`, `dashboard_routes.py`, and `repository_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file acts as a central repository for schemas related to advanced features, grouping them logically. The schemas are detailed and reflect the complex relationships between different parts of the application (e.g., a PR analysis having multiple test case deltas).
- Special configurations, assets, or third-party libraries if present: Uses Pydantic and Python's `Enum`.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/project.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/project.py
- Purpose or role in the project: This file defines the Pydantic schemas for the core project management entities: Project, Milestone, Test Suite, Test Case, and Test Run. This file seems to be an older or potentially redundant version, as `test_management.py` and `testworthy.py` define similar schemas.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines `Base`, `Create`, `Update`, and response schemas for `Project`, `Milestone`, `TestSuite`, `TestCase`, and `TestRun`. The structure is standard, with `Create` schemas for input, `Update` for partial updates, and the main schema (e.g., `Project`) for API responses.
- Important interactions or dependencies with other files or modules: These schemas would be used by the corresponding API route files (`project_routes.py`, `milestone_routes.py`, etc.). The presence of similar schemas in other files suggests a refactoring might have occurred.
- Notable implementation details, architectural patterns, or non-trivial techniques: Follows the standard schema separation pattern for Pydantic and FastAPI.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic and imports enums from the models.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/test_management.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/test_management.py
- Purpose or role in the project: This file defines Pydantic schemas for core test management entities, including Test Cases, Test Suites, Test Executions, and Test Plans.
- Main components, functions, classes, or constants with brief technical descriptions:
- `TestCase` schemas: `TestCaseBase`, `TestCaseCreate`, `TestCaseUpdate`, and `TestCase` (response model).
- `TestSuite` schemas: `TestSuiteBase`, `TestSuiteCreate`, `TestSuiteUpdate`, and `TestSuite` (response model).
- `TestExecution` schemas: `TestExecutionBase`, `TestExecutionCreate`, `TestExecutionUpdate`, and `TestExecution` (response model). `TestExecutionResultCreate` is a specific schema for the endpoint where results are submitted, including optional defect information.
- `TestPlan` schemas: `TestPlanBase`, `TestPlanCreate`, `TestPlanUpdate`, `TestPlan` (response model).
- `TestPlanItem` schemas: `TestPlanItemBase` and `TestPlanItemCreate` for linking test cases to plans.
- Important interactions or dependencies with other files or modules: These schemas are used by the API routes in `case_routes.py`, `suite_routes.py`, `run_routes.py`, and `test_plan_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `TestExecutionResultCreate` schema is a good example of a specialized input schema tailored to a specific API endpoint's needs, combining execution status with optional defect creation fields.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/testworthy.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/testworthy.py
- Purpose or role in the project: This file contains another set of Pydantic schemas for the main entities of the application. Its existence alongside `project.py` and `test_management.py` suggests it may be part of a refactoring or an alternative grouping of schemas.
- Main components, functions, classes, or constants with brief technical descriptions: The file defines `Base`, `Create`, `Update`, and `Response` schemas for `Project`, `Milestone`, `TestSuite`, `TestCase`, `TestRun`, and `TestExecution`. The `TestCaseResponse` schema notably includes `assigned_to_name`, indicating it's designed for responses where the assignee's user object has been joined and the name extracted.
- Important interactions or dependencies with other files or modules: These schemas are likely used by the API routes. For example, the `TestCaseResponse` schema with `assigned_to_name` perfectly matches the data structure created in the `get_test_cases` endpoint in `case_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file seems to be the most up-to-date collection of response schemas, as they include derived fields like `assigned_to_name` that are constructed in the API routes.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/schemas/user.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/schemas/user.py
- Purpose or role in the project: This file defines the Pydantic schemas related to user management and authentication.
- Main components, functions, classes, or constants with brief technical descriptions:
- `UserBase`: Defines the basic user fields: `email`, `name`, `role`, `avatar_url`, etc.
- `UserCreate`: Inherits from `UserBase` and adds a `password` field for creating new users.
- `UserUpdate`: A schema for updating user information, where all fields are optional. It also includes an optional `password` field for admins to reset passwords.
- `UserChangePassword`: A specific schema for the `/me/change-password` endpoint, requiring `current_password` and `new_password`.
- `User`: The main response schema for user objects, excluding sensitive information like the password hash.
- `UserInDB`: An internal schema that includes the `password_hash`, typically used for reading from the database.
- It also re-defines the authentication schemas (`Token`, `TokenData`, etc.) that are also present in `auth_schemas.py`, indicating some redundancy.
- Important interactions or dependencies with other files or modules: These schemas are used by `user_routes.py` for creating, updating, and returning user data, and by `authentication.py` for handling login requests.
- Notable implementation details, architectural patterns, or non-trivial techniques: The separation of `UserCreate` (with password) from `User` (response, without password) is a critical security practice to avoid ever sending password hashes to the client.
- Special configurations, assets, or third-party libraries if present: Uses Pydantic.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/__init__.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/__init__.py
- Purpose or role in the project: This is a standard Python package initializer file for the `services` directory.
- Main components, functions, classes, or constants with brief technical descriptions: It contains a comment indicating its purpose.
- Important interactions or dependencies with other files or modules: This file makes the `services` directory a Python package, allowing the application to import service modules like `from app.services import chunk_processor`.
- Notable implementation details, architectural patterns, or non-trivial techniques: Standard Python project structure.
- Special configurations, assets, or third-party libraries if present: None.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/__init__.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/__init__.py
- Purpose or role in the project: This is the package initializer for the `ai_providers` directory. It imports and exposes all the individual provider classes, making them easily accessible from a single import point.
- Main components, functions, classes, or constants with brief technical descriptions: It imports the `OpenAIProvider`, `GeminiProvider`, `VertexProvider`, `AnthropicProvider`, and `OpenRouterProvider` classes from their respective modules. It uses `__all__` to explicitly define the public API of this package.
- Important interactions or dependencies with other files or modules: This file allows other modules, like `unified_ai_client.py`, to import all providers easily, for example: `from .ai_providers import OpenAIProvider`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a good example of creating a clean public interface for a package, hiding the individual file structure from the consumer of the package.
- Special configurations, assets, or third-party libraries if present: None.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/anthropic_provider.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/anthropic_provider.py
- Purpose or role in the project: This file implements the client for interacting with the Anthropic Claude API. It is one of the strategies used by the `UnifiedAIClient`.
- Main components, functions, classes, or constants with brief technical descriptions: It contains a single class `AnthropicProvider` with a static async method `generate`. This method constructs the API request payload specific to the Anthropic Messages API format (a list of messages with roles), sets the required headers (including `x-api-key` and `anthropic-version`), and sends the request using `httpx.AsyncClient`. It then parses the response to extract the generated text from the `content` array.
- Important interactions or dependencies with other files or modules: This module is called by the `UnifiedAIClient` when the specified provider is 'anthropic'.
- Notable implementation details, architectural patterns, or non-trivial techniques: The implementation uses `httpx.AsyncClient` for making asynchronous HTTP requests, which is suitable for a FastAPI application. It combines the `system_prompt` and `user_prompt` into a single user message, which is a common way to interact with models that don't have a distinct system prompt field in their primary message structure.
- Special configurations, assets, or third-party libraries if present: Uses the `httpx` library for HTTP requests.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/gemini_provider.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/gemini_provider.py
- Purpose or role in the project: This file implements the client for interacting with the Google Gemini API.
- Main components, functions, classes, or constants with brief technical descriptions: It contains the `GeminiProvider` class with a static async method `generate`. This method formats the request payload according to the Gemini API's structure, including the `contents` array and `generationConfig`. It also includes `safetySettings` to disable content filtering (`BLOCK_NONE`), which is often necessary to prevent false positives when processing code. It sends the request to the `generativelanguage.googleapis.com` endpoint using `httpx`.
- Important interactions or dependencies with other files or modules: This module is used by the `UnifiedAIClient` when the provider is 'gemini'.
- Notable implementation details, architectural patterns, or non-trivial techniques: The inclusion of `safetySettings` is a specific and important detail for this provider, as Gemini's default safety filters can be aggressive and block valid code generation responses.
- Special configurations, assets, or third-party libraries if present: Uses the `httpx` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/openai_provider.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/openai_provider.py
- Purpose or role in the project: This file implements the client for interacting with the OpenAI API (e.g., for GPT models).
- Main components, functions, classes, or constants with brief technical descriptions: It defines the `OpenAIProvider` class with a static async method `generate`. This method constructs a request payload compliant with the OpenAI Chat Completions API, with separate `system` and `user` roles in the `messages` array. It sends the request to `api.openai.com` using `httpx`, including the `Authorization: Bearer {api_key}` header. It parses the response to extract the message content from `choices[0].message.content`.
- Important interactions or dependencies with other files or modules: This is called by the `UnifiedAIClient` when the provider is 'openai'.
- Notable implementation details, architectural patterns, or non-trivial techniques: The implementation correctly uses the separate system and user roles, which is the recommended way to provide instructions and prompts to OpenAI models.
- Special configurations, assets, or third-party libraries if present: Uses the `httpx` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/openrouter_provider.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/openrouter_provider.py
- Purpose or role in the project: This file implements the client for interacting with the OpenRouter API, which is an aggregator for various AI models.
- Main components, functions, classes, or constants with brief technical descriptions: It defines the `OpenRouterProvider` class with a static async method `generate`. The implementation is very similar to the `OpenAIProvider`, as OpenRouter provides an OpenAI-compatible API. It sends a request to `openrouter.ai`, setting custom `HTTP-Referer` and `X-Title` headers as recommended by OpenRouter for identifying the application. The response parsing is identical to OpenAI's.
- Important interactions or dependencies with other files or modules: This module is used by the `UnifiedAIClient` when the provider is 'openrouter'.
- Notable implementation details, architectural patterns, or non-trivial techniques: The key detail here is the use of the `HTTP-Referer` and `X-Title` headers, which is specific to OpenRouter's API requirements.
- Special configurations, assets, or third-party libraries if present: Uses the `httpx` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/vertex_provider.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/ai_providers/vertex_provider.py
- Purpose or role in the project: This file implements the client for interacting with Google's Vertex AI platform, specifically for its generative models (like Gemini). Unlike the regular Gemini provider, this one uses Google Cloud service account authentication.
- Main components, functions, classes, or constants with brief technical descriptions: It defines the `VertexProvider` class with a static async method `generate`. This method first validates that the required environment variables for Google Cloud (`GCP_PROJECT_ID`, `GOOGLE_APPLICATION_CREDENTIALS`) are set. It then defines a synchronous inner function `generate_content` which uses the official `vertexai` Python SDK. Inside this function, it calls `vertexai.init()`, instantiates a `GenerativeModel`, and calls its `generate_content` method. To avoid blocking the FastAPI event loop, the synchronous SDK call is wrapped in `loop.run_in_executor(None, generate_content)`.
- Important interactions or dependencies with other files or modules: This module is used by the `UnifiedAIClient` when the provider is 'vertex'. It depends on `app.core.config.settings` for Google Cloud configuration.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of `asyncio.get_event_loop().run_in_executor()` is a crucial technique for integrating synchronous libraries (like the Vertex AI SDK) into an asynchronous application (FastAPI) without blocking the main thread. The function also includes detailed logging and error checking for the cloud configuration.
- Special configurations, assets, or third-party libraries if present: It requires the `vertexai` library (part of `google-cloud-aiplatform`). It relies on a service account JSON key file, the path to which is specified by the `GOOGLE_APPLICATION_CREDENTIALS` environment variable.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/chunk_processor.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/chunk_processor.py
- Purpose or role in the project: This file contains the core logic for the AI-powered project import feature. It handles splitting large codebases into manageable chunks, processing each chunk with an AI to generate test cases, and aggregating the results.
- Main components, functions, classes, or constants with brief technical descriptions:
- `retry_with_timeout`: An async helper function that retries a given function with a timeout, implementing an exponential backoff strategy.
- `ChunkResult` & `ProcessingResult`: Dataclasses for structuring chunk data and processing outcomes.
- `EnhancedChunkProcessor`: The main class.
  - `__init__`: Initializes a `TokenManager` and sets up model-specific context window limits with a 20% buffer (i.e., it plans to use 80% of the window).
  - `prepare_chunks_with_overlap`: Splits a large string of code into chunks. It ensures each chunk fits within the model's available context window and adds a 20% overlap of content between consecutive chunks to maintain context.
  - `process_chunk_with_ai`: Takes a single chunk, formats a detailed prompt using templates from `ai_prompts.json`, calls the `UnifiedAIClient` to get an AI response, and then parses the resulting JSON. This entire process is wrapped in the `retry_with_timeout` logic.
  - `aggregate_chunk_results`: Takes the results from all processed chunks, formats another prompt for the AI to perform deduplication and organization, calls the AI again, and then formats the final structured response.
- Important interactions or dependencies with other files or modules: This service is a central orchestrator. It uses `TokenManager` for token counting, `UnifiedAIClient` to call the AI, and `ai_prompts.json` for prompt templates. It is primarily used by `app/api/ai_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This service implements the "map-reduce" pattern for LLMs. The `process_chunk_with_ai` function is the "map" step (processing each part independently), and `aggregate_chunk_results` is the "reduce" step (combining the results). The chunking with overlap is a key technique to avoid losing context at chunk boundaries. The robust retry and JSON parsing logic (including attempts to fix truncated JSON) makes the interaction with the LLM more resilient.
- Special configurations, assets, or third-party libraries if present: Depends on the custom service modules within the project.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/code_analysis.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/code_analysis.py
- Purpose or role in the project: This service acts as a high-level orchestrator for the entire codebase analysis pipeline, combining ZIP processing and AI analysis into a single service.
- Main components, functions, classes, or constants with brief technical descriptions:
- `CodeAnalysisResult` and `AnalysisConfig`: Dataclasses to structure the input configuration and the final output of the analysis.
- `CodeAnalysisService`: The main class with static methods.
  - `analyze_zip_file`: The primary method. It takes raw ZIP file content, validates its size, calls `ZipProcessor.process_zip_file` to extract and merge code, and then calls `AIProjectProcessor.analyze_with_ai` to generate the test structure. Finally, it compiles detailed metadata about the entire process.
  - `analyze_code_text`: A similar method that works on a raw string of code instead of a ZIP file.
  - `_analyze_relationships` and `validate_project_structure`: Helper methods to generate metadata about the quality and completeness of the AI-generated project structure (e.g., checking for orphaned test cases).
- Important interactions or dependencies with other files or modules: This service acts as a facade, coordinating the `ZipProcessor` and `AIProjectProcessor` services. It is used by the `ai_routes.py` endpoints for project import.
- Notable implementation details, architectural patterns, or non-trivial techniques: This service encapsulates the entire complex workflow of "ZIP file to complete test project". It demonstrates a clear separation of concerns, with `ZipProcessor` handling file extraction, `AIProjectProcessor` handling the AI interaction, and this service managing the overall pipeline and metadata generation.
- Special configurations, assets, or third-party libraries if present: Depends on other custom services within the project.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/github_integration_service.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/github_integration_service.py
- Purpose or role in the project: This service contains the business logic for the GitHub integration, specifically for analyzing pull requests to generate "self-healing" test case recommendations.
- Main components, functions, classes, or constants with brief technical descriptions:
- `GitHubIntegrationService`: The main service class.
  - `analyze_pull_request`: An async static method that orchestrates the analysis. It takes a `PRAnalysis` database object, retrieves project context (existing test cases, suites), generates a detailed prompt for the AI including the PR diff, calls the `UnifiedAIClient`, parses the JSON response, and then creates `TestCaseDelta` records in the database based on the AI's suggestions. It also logs the start, success, or failure of the analysis to the `IntegrationLog` table.
  - `_get_project_context`, `_generate_analysis_prompt`, `_parse_ai_response`, `_create_test_deltas`: Private helper methods that break down the analysis process into logical steps.
- `GitHubAPIClient`: A simple, dedicated client for making API calls to GitHub. It has methods like `get_pull_request_diff` and `get_pull_request_files` that use `httpx` to fetch data from the GitHub API, handling authentication with a provided access token.
- Important interactions or dependencies with other files or modules: This service is triggered by the webhook handlers in `webhook_routes.py` (specifically, by the `analyze_pr_with_github_data` background task). It uses the `UnifiedAIClient` to interact with an AI model. It reads from and writes to several database models, including `PRAnalysis`, `TestCaseDelta`, and `IntegrationLog`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `_generate_analysis_prompt` method is a good example of providing rich context to an LLM, including existing test cases, suites, and the code diff, to get high-quality, context-aware recommendations. The entire process is designed to be run asynchronously, suitable for a background task triggered by a webhook.
- Special configurations, assets, or third-party libraries if present: Uses `httpx` for making API calls to GitHub.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/pricing_manager.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/pricing_manager.py
- Purpose or role in the project: This service is responsible for managing and calculating the costs of AI model usage based on a configuration file.
- Main components, functions, classes, or constants with brief technical descriptions:
- `PricingManager`: The main class.
  - `__init__`: In its constructor, it loads pricing data from `app/config/pricing_config.json`.
  - `get_model_pricing`: Retrieves the pricing information (cost per 1M input/output tokens) for a specific provider and model.
  - `calculate_cost`: Takes the number of input and output tokens and a model name, looks up the pricing, and returns the calculated cost.
  - `get_all_providers` and `get_provider_models`: Helper methods to list available providers and models from the config.
- `get_pricing_manager`: A factory function that returns a global singleton instance of the `PricingManager`.
- Important interactions or dependencies with other files or modules: This service is used by `app/api/ai_routes.py` in the `estimate-tokens` endpoint to provide cost estimates to the user. It depends on the `app/config/pricing_config.json` file for its data.
- Notable implementation details, architectural patterns, or non-trivial techniques: This service decouples pricing information from the application logic. By using a singleton pattern (`get_pricing_manager`), the pricing configuration is loaded from disk only once, improving performance.
- Special configurations, assets, or third-party libraries if present: Depends on the `pricing_config.json` asset.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/project_import_processor.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/project_import_processor.py
- Purpose or role in the project: This service contains the core logic for analyzing a block of code with an AI and parsing the response into a structured set of test management entities (milestones, plans, suites, cases, runs). It was formerly named `ai_processor.py`.
- Main components, functions, classes, or constants with brief technical descriptions:
- Dataclasses: Defines several dataclasses like `Milestone`, `TestPlan`, `TestSuite`, `TestCase`, `TestRun`, and `ProjectStructure` to hold the parsed AI response in a structured way.
- `AIProjectProcessor`: The main class with static methods.
  - `generate_analysis_prompt`: Creates the detailed prompt to send to the AI, instructing it to analyze the provided code and return a JSON object with the full test project hierarchy. It can include a requirement for a minimum number of test cases.
  - `parse_ai_response`: A robust function for parsing the JSON response from the AI. It includes extensive cleaning and error handling logic, such as stripping markdown code blocks, attempting to fix truncated or malformed JSON, and even trying to parse sections of a broken response.
  - `analyze_with_ai`: The main orchestrator method. It generates the prompt, calls the appropriate AI provider via a private helper method (e.g., `_call_openai`), and then parses the response. It wraps the entire process in a `retry_with_timeout` function for resilience.
  - `_call_*` methods: Private helper methods (`_call_openai`, `_call_gemini`, etc.) that use the individual provider modules from `app.services.ai_providers` to make the actual API calls.
- Important interactions or dependencies with other files or modules: This service is a key part of the AI-powered project creation flow. It is used by `CodeAnalysisService` and the `ai_routes.py` endpoints. It uses the provider modules from `app.services.ai_providers`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `parse_ai_response` function is highly sophisticated. It shows a practical approach to dealing with the unreliability of LLM JSON outputs by implementing multiple layers of cleaning, fixing, and partial parsing to salvage as much data as possible from a potentially malformed response. The use of `retry_with_timeout` makes the service resilient to transient network or API errors.
- Special configurations, assets, or third-party libraries if present: Depends on the various AI provider modules in the project.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/rate_limiter.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/rate_limiter.py
- Purpose or role in the project: This file implements an advanced, token-aware rate limiting system for making calls to external AI APIs. It is designed to manage requests per minute/hour/day, tokens per minute/hour/day, and concurrent requests.
- Main components, functions, classes, or constants with brief technical descriptions:
- `ProviderLimits`: A dataclass to define the rate limit configuration for a provider.
- `RateLimitState`: A dataclass to track the current usage state for a provider.
- `PendingRequest`: A dataclass representing a request waiting in the queue.
- `RateLimiter`: The main class. It maintains limits and state for each provider, a priority queue for pending requests, and uses `asyncio.Semaphore` for managing concurrency.
  - `execute_with_limits`: The main public method. It checks if a request can run immediately; if not, it adds it to a priority queue.
  - `_can_execute_now`: Checks all rate limit counters (requests, tokens, concurrency, backoff period) to see if a request can proceed.
  - `_execute_request`: Wraps the execution of the request, updates counters, and handles failures by triggering an adaptive backoff.
  - `_handle_request_failure`: Implements exponential backoff logic, increasing the wait time after consecutive failures.
  - `_process_queue`: A background asyncio task that continuously checks the pending queues and executes requests when capacity becomes available.
- `get_rate_limiter`: A factory function that provides a global singleton instance of the `RateLimiter`.
- Important interactions or dependencies with other files or modules: This service is intended to be wrapped around any call to an external AI API to ensure compliance with their rate limits. It is used in `ai_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a sophisticated implementation of a rate limiter. Key features include: being token-aware (not just request-aware), handling multiple time windows (minute, hour, day), managing concurrency with semaphores, using a priority queue for pending requests, and implementing adaptive exponential backoff on failures.
- Special configurations, assets, or third-party libraries if present: Uses Python's `asyncio` library extensively for concurrency and task management.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/test_generator.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/test_generator.py
- Purpose or role in the project: This service provides advanced functionality for generating test cases and entire project structures from textual requirements, with more control over the output than the general-purpose `project_import_processor`.
- Main components, functions, classes, or constants with brief technical descriptions:
- `TestGenerationConfig`: A dataclass for specifying detailed generation parameters, including min/max test cases, types of tests to include (edge cases, security), and target distributions for priority and type.
- `GeneratedTestStructure`: A dataclass for the structured output.
- `TestCaseGenerator`: The main service class.
  - `generate_enhanced_prompt`: Creates a highly specific AI prompt for generating test cases, incorporating the detailed requirements from the `TestGenerationConfig`.
  - `generate_test_cases_for_requirements`: Orchestrates the generation of a list of test cases for a given set of requirements.
  - `_adjust_distributions`, `_adjust_priority_distribution`, `_adjust_type_distribution`: Helper methods that post-process the AI-generated test cases to enforce the desired priority and type distributions (e.g., ensure 30% high priority, 50% medium, etc.).
  - `generate_complete_project_structure`: A high-level method that can generate a full project structure (milestones, plans, etc.) from requirements. It can either call `AIProjectProcessor` for code analysis or use its own prompt for requirements-based generation.
- Important interactions or dependencies with other files or modules: This service uses `AIProjectProcessor`'s helper methods (like `_call_openai`) to interact with the AI models. It is used by endpoints in `ai_routes.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The distribution adjustment logic is a notable feature. It allows the user to guide the AI's output distribution and then programmatically enforces it, providing more predictable and controlled test generation. This post-processing step adds a layer of determinism on top of the stochastic output of the LLM.
- Special configurations, assets, or third-party libraries if present: Depends on other custom services in the project.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/token_manager.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/token_manager.py
- Purpose or role in the project: This file implements a service for managing and tracking AI model token usage. It provides accurate token counting for different models, validates requests against context windows and budgets, and tracks usage over time.
- Main components, functions, classes, or constants with brief technical descriptions:
- `ModelConfig`: A dataclass defining properties for each AI model, including its provider, context window, max output tokens, pricing, and the specific tokenizer encoding to use.
- `TokenManager`: The main class.
  - `MODEL_CONFIGS`: A large dictionary containing `ModelConfig` instances for many popular models from OpenAI, Anthropic, and Gemini.
  - `count_tokens`: The primary method for counting tokens. It looks up the model's configuration and delegates to a provider-specific counting method (`_count_openai_tokens`, `_count_anthropic_tokens`, etc.).
  - `_count_openai_tokens`: Uses the `tiktoken` library for accurate OpenAI token counting based on the model's encoding name.
  - `_count_anthropic_tokens`, `_count_gemini_tokens`: Use an approximation (e.g., characters / 3.5) since their tokenizers are not publicly available.
  - `validate_request`: A comprehensive validation method that checks a request's token count against the model's context window and configured budget limits (per request, minute, hour, day, and cost).
  - `record_usage`: Records the token usage and estimated cost for a completed API call, storing it in sliding time windows for budget tracking.
- `get_token_manager`: A factory function that returns a global singleton instance.
- Important interactions or dependencies with other files or modules: This service is used by `ai_routes.py` for token estimation and by other AI services like `rate_limiter.py` and `chunk_processor.py` for validation and counting.
- Notable implementation details, architectural patterns, or non-trivial techniques: The manager provides a unified interface for token counting across different providers, abstracting away the implementation details (exact vs. approximate). The `validate_request` method is very thorough, checking multiple constraints to prevent API errors and cost overruns.
- Special configurations, assets, or third-party libraries if present: Uses the `tiktoken` library for accurate OpenAI tokenization.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/unified_ai_client.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/unified_ai_client.py
- Purpose or role in the project: This file implements the Unified AI Client, which acts as a facade or router to the various individual AI provider modules. This is the result of the refactoring described in `AI_PROVIDER_REFACTORING.md`.
- Main components, functions, classes, or constants with brief technical descriptions:
- `AIProvider`: An `Enum` for the supported providers.
- `UnifiedAIClient`: The main class.
  - `__init__`: The constructor takes the provider, model, API key, and other generation parameters.
  - `generate_content`: The primary method. It contains a simple `if/elif/else` block that checks the `self.provider` and calls the static `generate` method of the corresponding provider module (`OpenAIProvider`, `GeminiProvider`, etc.), passing along all the necessary parameters.
- Important interactions or dependencies with other files or modules: This client is the primary way that services like `chunk_processor.py` and `project_import_processor.py` interact with AI models. It imports and delegates calls to all the provider modules in `app.services.ai_providers`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This class implements the Facade pattern and is a key part of the Strategy pattern. It provides a single, simple interface for making AI calls, hiding the implementation details of each provider's unique API structure and requirements. This makes the rest of the codebase much cleaner and easier to maintain.
- Special configurations, assets, or third-party libraries if present: Depends on the custom provider modules.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/services/zip_processor.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/services/zip_processor.py
- Purpose or role in the project: This service is responsible for processing uploaded ZIP archives containing source code. It extracts files, filters them, and merges their content into a single string for AI analysis.
- Main components, functions, classes, or constants with brief technical descriptions:
- `CodeFile` and `ProcessedProject`: Dataclasses for structuring the extracted file data and the final processed result.
- `ZipProcessor`: The main class.
  - `SUPPORTED_EXTENSIONS`: A large set of file extensions that are considered source code or relevant text.
  - `EXCLUDED_PATTERNS`: A set of directory and file names to ignore (e.g., `node_modules`, `.git`).
  - `process_zip_file`: The main static method. It takes the raw bytes of a ZIP file, opens it in memory using `io.BytesIO`, iterates through the files, filters them based on supported extensions and excluded paths, reads their content, and stores them as `CodeFile` objects. It then calls `merge_code_files` and uses the `TokenManager` to calculate the total token count.
  - `merge_code_files`: A static method that takes a list of `CodeFile` objects and concatenates their content into a single, well-formatted string, with clear separators and headers for each file and directory.
  - `get_file_statistics`: A static method that calculates statistics about the extracted files (e.g., counts by extension, total lines).
- Important interactions or dependencies with other files or modules: This service is the first step in the AI project import pipeline. It is used by `CodeAnalysisService` and the `ai_routes.py` endpoints. It uses the `TokenManager` for token counting.
- Notable implementation details, architectural patterns, or non-trivial techniques: The service processes the ZIP file entirely in memory, which is efficient and avoids writing to disk on the server. The `merge_code_files` function formats the output in a way that is highly readable for an LLM, providing clear context about the file structure.
- Special configurations, assets, or third-party libraries if present: Uses Python's built-in `zipfile` and `io` libraries.

FILE: testworthy-pro-dev/testworthy-pro-backend/app/test_vertex.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/app/test_vertex.py
- Purpose or role in the project: This is a test or debugging script for experimenting with Google's Vertex AI and Anthropic's Vertex integration.
- Main components, functions, classes, or constants with brief technical descriptions: The file contains two main blocks of code, one of which is commented out.
- Commented-out block: This section shows how to use the native `vertexai` SDK to call a Gemini model (`claude-haiku-4-5@20251001` - note this model name seems to be a mix of Claude and Gemini, likely a typo). It initializes the SDK with a project ID and location and calls `model.generate_content`.
- Active block: This section demonstrates how to use the `anthropic` library's Vertex AI integration (`AnthropicVertex`). It sets the `GOOGLE_APPLICATION_CREDENTIALS` environment variable, specifies a project ID and region, initializes the `AnthropicVertex` client, and makes a call to the `claude-sonnet-4-5@20250929` model to generate a recipe for banana bread.
- Important interactions or dependencies with other files or modules: This is a standalone script. It directly sets the `GOOGLE_APPLICATION_CREDENTIALS` environment variable, which is a common way to configure Google Cloud SDKs.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script demonstrates two different ways to interact with models on Vertex AI: using the native Google SDK and using a third-party library (Anthropic's) that provides a Vertex AI backend.
- Special configurations, assets, or third-party libraries if present: Requires the `vertexai` and/or `anthropic` Python libraries. It also requires a Google Cloud service account key file.

FILE: testworthy-pro-dev/testworthy-pro-backend/apply_defect_migration.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/apply_defect_migration.py
- Purpose or role in the project: This is a standalone Python script to manually apply a specific database migration: adding the `test_run_id` column to the `test_case_defects` table.
- Main components, functions, classes, or constants with brief technical descriptions: The script defines a single function `apply_migration`. This function connects to the database using the SQLAlchemy `engine` from the application's session configuration. It then executes raw SQL commands using `conn.execute(text(...))`. The commands add the `test_run_id` column with a foreign key constraint to the `test_runs` table and then create an index on this new column.
- Important interactions or dependencies with other files or modules: It imports the `engine` from `app.database.session` to connect to the database. The SQL commands it executes are the same as those in `migrations/add_test_run_id_to_defects.sql`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This script represents a manual approach to database migrations, an alternative to using a full migration framework like Alembic for simple changes. The use of `ADD COLUMN IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` makes the script idempotent.
- Special configurations, assets, or third-party libraries if present: Uses SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/check_enum.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/check_enum.py
- Purpose or role in the project: This is a debugging script used to compare the values of the `testexecutionstatus` ENUM type in the PostgreSQL database with the values defined in the `TestExecutionStatus` enum in the Python application code.
- Main components, functions, classes, or constants with brief technical descriptions: The script first connects directly to the database using `psycopg2` and the `DATABASE_URL` from the `.env` file. It queries the `pg_enum` and `pg_type` system catalogs to get the labels for the `testexecutionstatus` type. Then, it imports the `TestExecutionStatus` enum from `app.database.models` and prints its values. This allows a developer to see if there is a mismatch.
- Important interactions or dependencies with other files or modules: It reads the `.env` file for the `DATABASE_URL` and imports the `TestExecutionStatus` enum from `app.database.models`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This script is a useful diagnostic tool for a common problem in applications that use database enums: ensuring the enum definitions in the application code stay synchronized with the schema in the database.
- Special configurations, assets, or third-party libraries if present: Requires `psycopg2` and `python-dotenv`.

FILE: testworthy-pro-dev/testworthy-pro-backend/debug_char.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/debug_char.py
- Purpose or role in the project: This is a debugging script designed to investigate a JSON parsing error. It loads a specific JSON file that contains a raw AI response, extracts the text, and inspects the character at a specific position (10325) where a parsing error was reported.
- Main components, functions, classes, or constants with brief technical descriptions: The script opens a hardcoded file path, loads the JSON, and extracts the `response_text`. It then removes the markdown wrappers (` ```json `). It prints the context around the problematic position, the character at that position (using `repr()` to make control characters visible), its ordinal value (`ord()`), and checks if it's a control character. It also calculates the number of preceding quote characters to determine if the error is occurring inside a string.
- Important interactions or dependencies with other files or modules: It reads a specific file from the `app/temp` directory, which is likely where the application saves problematic AI responses.
- Notable implementation details, architectural patterns, or non-trivial techniques: This script is a good example of targeted debugging for data parsing issues. By printing the character's representation, ordinal value, and surrounding context, it helps pinpoint the exact cause of a `JSONDecodeError`, such as an unescaped control character inside a string.
- Special configurations, assets, or third-party libraries if present: None, uses standard Python libraries.

FILE: testworthy-pro-dev/testworthy-pro-backend/github_integration_migration.sql
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/github_integration_migration.sql
- Purpose or role in the project: This is a raw SQL script for manually applying database schema changes required for the GitHub integration feature. It is the SQL equivalent of the Alembic migration script `abc123_add_github_tables.py`.
- Main components, functions, classes, or constants with brief technical descriptions: The script contains several SQL commands. It uses `ALTER TABLE ... ADD COLUMN IF NOT EXISTS` to add new columns to the `repository_configs` and `pr_analyses` tables. It then uses `CREATE TABLE IF NOT EXISTS` to create the `test_case_deltas` and `integration_logs` tables, defining all their columns, types, primary keys, and foreign key constraints.
- Important interactions or dependencies with other files or modules: This script modifies the database schema directly. It's an alternative to using the Alembic migration scripts.
- Notable implementation details, architectural patterns, or non-trivial techniques: The use of `IF NOT EXISTS` makes the script idempotent, so it can be run multiple times without causing errors. This is a good practice for manual migration scripts.
- Special configurations, assets, or third-party libraries if present: The syntax is specific to PostgreSQL.

FILE: testworthy-pro-dev/testworthy-pro-backend/master_seed.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/master_seed.py
- Purpose or role in the project: This script is used to populate a newly created database with initial data. It creates a default admin user, several test users with different roles, and a complete demo project.
- Main components, functions, classes, or constants with brief technical descriptions:
- `hash_password`: A helper function using `bcrypt` to hash passwords.
- `check_database_tables`: Verifies that required tables exist before trying to insert data.
- `add_theme_preference_column`: A small migration function that adds a column to the users table if it doesn't exist, ensuring backward compatibility.
- `create_admin_user` and `create_test_users`: Functions that create the default user accounts, checking if they already exist.
- `create_demo_project`: A large function that creates a demo `Project` ("AI Tokenizer API") and populates it with associated `Milestone`s, `TestSuite`s, `TestCase`s, a `TestPlan`, and a `TestRun`.
- `main`: The main function that orchestrates the process and prints progress and summary information to the console.
- Important interactions or dependencies with other files or modules: This script is a critical part of the application setup process, as described in `DATABASE_SETUP.md`. It interacts with almost all of the SQLAlchemy models from `app.database.models` to insert data. It uses `SessionLocal` from `app.database.session` to get a database connection.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script is idempotent; it checks for the existence of users before creating them to avoid duplicates. The inclusion of a small schema migration (`add_theme_preference_column`) within the seed script is a practical way to handle minor schema updates in a development environment without a full migration framework.
- Special configurations, assets, or third-party libraries if present: Uses `bcrypt` for password hashing and SQLAlchemy for database operations.

FILE: testworthy-pro-dev/testworthy-pro-backend/migrations/add_duration_minutes.sql
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/migrations/add_duration_minutes.sql
- Purpose or role in the project: This is a raw SQL script for applying a database migration. It adds a `duration_minutes` column to the `test_executions` table and updates the `testexecutionstatus` ENUM type.
- Main components, functions, classes, or constants with brief technical descriptions: The script performs several actions:
1. `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`: Adds the `duration_minutes` column.
2. `ALTER TABLE ... ALTER COLUMN ... TYPE VARCHAR(20)`: Temporarily changes the `status` column to a string type.
3. `DROP TYPE IF EXISTS testexecutionstatus CASCADE`: Drops the old ENUM type.
4. `CREATE TYPE testexecutionstatus AS ENUM (...)`: Recreates the ENUM with the new, desired set of values ('pending', 'passed', 'failed', etc.).
5. `ALTER TABLE ... ALTER COLUMN ... TYPE testexecutionstatus USING status::testexecutionstatus`: Converts the string column back to the new ENUM type.
- Important interactions or dependencies with other files or modules: This script modifies the `test_executions` table and the `testexecutionstatus` type, which are defined in the `TestExecution` and `TestExecutionStatus` model/enum in `app/database/models.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The process of altering an ENUM type in PostgreSQL is non-trivial. This script follows the standard procedure: convert the column to text, drop the old type, create the new type, and convert the column back, casting the existing string values to the new enum type.
- Special configurations, assets, or third-party libraries if present: The syntax is specific to PostgreSQL.

FILE: testworthy-pro-dev/testworthy-pro-backend/migrations/add_test_run_id_to_defects.sql
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/migrations/add_test_run_id_to_defects.sql
- Purpose or role in the project: This is a raw SQL script to apply a database migration. It adds a `test_run_id` column to the `test_case_defects` table, allowing defects to be linked directly to the test run during which they were found.
- Main components, functions, classes, or constants with brief technical descriptions: The script contains three SQL commands:
1. `ALTER TABLE test_case_defects ADD COLUMN ...`: Adds the `test_run_id` integer column and defines a foreign key reference to the `test_runs` table with the `ON DELETE SET NULL` constraint.
2. `CREATE INDEX ...`: Creates an index on the new `test_run_id` column to improve query performance.
3. `COMMENT ON COLUMN ...`: Adds a descriptive comment to the new column in the database schema for documentation purposes.
- Important interactions or dependencies with other files or modules: This modifies the `test_case_defects` table schema, corresponding to the `TestCaseDefect` model.
- Notable implementation details, architectural patterns, or non-trivial techniques: The `ON DELETE SET NULL` constraint is a good choice here. It means if a test run is deleted, the link to it from any defects will be removed (set to NULL), but the defect record itself will remain, preventing accidental data loss.
- Special configurations, assets, or third-party libraries if present: The syntax is specific to PostgreSQL.

FILE: testworthy-pro-dev/testworthy-pro-backend/migrations/run_migration.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/migrations/run_migration.py
- Purpose or role in the project: This is a standalone Python script to execute the migration defined in `add_duration_minutes.sql`. It connects to the database and runs the necessary SQL commands programmatically.
- Main components, functions, classes, or constants with brief technical descriptions: The script loads the `DATABASE_URL` from the `.env` file. It then uses SQLAlchemy's `create_engine` to connect to the database. Inside a `try...except` block, it executes a series of raw SQL commands using `conn.execute(text(...))`. These commands are the same as in `add_duration_minutes.sql`: add the `duration_minutes` column, convert the `status` column to VARCHAR, drop and recreate the `testexecutionstatus` ENUM, and convert the column back to the new ENUM type. It also includes `UPDATE` statements to map old status values (like 'pass') to the new ones ('passed').
- Important interactions or dependencies with other files or modules: It depends on `python-dotenv` to load the `.env` file and `SQLAlchemy` to interact with the database.
- Notable implementation details, architectural patterns, or non-trivial techniques: This script provides an alternative way to run a migration compared to using a tool like Alembic or a raw `.sql` file. It has the advantage of being runnable with just `python` and can include more complex logic if needed. The inclusion of `UPDATE` statements to migrate existing data (e.g., from 'pass' to 'passed') is a crucial part of a schema migration that also involves data transformation.
- Special configurations, assets, or third-party libraries if present: Requires `python-dotenv` and `SQLAlchemy`.

FILE: testworthy-pro-dev/testworthy-pro-backend/requirements.txt
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/requirements.txt
- Purpose or role in the project: This file lists all the Python package dependencies required for the backend application. The `pip` package manager uses this file to install the correct libraries.
- Main components, functions, classes, or constants with brief technical descriptions: The file contains a list of Python packages and their versions. Key dependencies include: `fastapi` (the web framework), `uvicorn` (the ASGI server), `sqlalchemy` (the database ORM), `psycopg2-binary` (PostgreSQL driver), `alembic` (database migration tool), `pydantic` and `pydantic-settings` (for data validation and settings management), `python-jose` and `bcrypt` (for authentication), and various AI SDKs like `openai`, `google-genai`, `vertexai`, and `anthropic`. The file appears to have encoding issues, with null bytes or extra spaces between characters. For example, `f a s t a p i` should be `fastapi`.
- Important interactions or dependencies with other files or modules: This file is used by running `pip install -r requirements.txt`, which is a standard step in setting up the backend development environment as described in `run.mD` and `master_seed.py`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The file appears to be corrupted or saved with an incorrect encoding (possibly UTF-16 with extra spacing), which could cause `pip install` to fail if not handled correctly.
- Special configurations, assets, or third-party libraries if present: This file defines all third-party Python libraries used by the backend.

FILE: testworthy-pro-dev/testworthy-pro-backend/reset_database.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/reset_database.py
- Purpose or role in the project: This is a utility script for developers to completely wipe and recreate the database schema. It's a destructive operation intended for resetting the local development environment.
- Main components, functions, classes, or constants with brief technical descriptions:
- `drop_all_tables`: This function connects to the database, inspects it to find all existing tables, and then executes a `DROP TABLE ... CASCADE` command for each one.
- `create_all_tables`: This function calls `Base.metadata.create_all(bind=engine)`, which uses SQLAlchemy to create all tables defined in the application's models.
- `main`: The main function that orchestrates the process. It first prompts the user for confirmation by requiring them to type 'RESET'. If confirmed, it calls `drop_all_tables` and then `create_all_tables`.
- Important interactions or dependencies with other files or modules: This script is a key part of the development workflow described in `DATABASE_SETUP.md`. It uses the `engine` and `Base` from the application's database configuration (`app.database.session` and `app.database.models`).
- Notable implementation details, architectural patterns, or non-trivial techniques: The script is designed to be safe by requiring explicit confirmation. The `drop_all_tables` function is robust because it dynamically discovers all tables using `inspect(engine)` and drops them with `CASCADE` to handle foreign key dependencies automatically.
- Special configurations, assets, or third-party libraries if present: Uses SQLAlchemy.

FILE: testworthy-pro-dev/testworthy-pro-backend/run.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/run.py
- Purpose or role in the project: This is the main executable script for starting the backend development server.
- Main components, functions, classes, or constants with brief technical descriptions: The script checks if it's being run as the main program (`if __name__ == "__main__":`). If so, it imports the `uvicorn` library and calls `uvicorn.run()`.
- The call `uvicorn.run("app.main:app", ...)` tells uvicorn to run the FastAPI application instance named `app` located in the `app.main` module. The options `host="0.0.0.0"` makes the server accessible on the network (not just localhost), `port=8000` sets the listening port, and `reload=True` enables auto-reloading, which automatically restarts the server whenever a code file is changed.
- Important interactions or dependencies with other files or modules: This script is the entry point for running the application. It directly targets `app.main.py` to find the FastAPI app instance.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is the standard way to run a FastAPI application during development using the Uvicorn ASGI server with hot-reloading enabled.
- Special configurations, assets, or third-party libraries if present: Requires the `uvicorn` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/simple_test.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/simple_test.py
- Purpose or role in the project: This is a debugging script to test the parsing of a specific, problematic JSON response from Vertex AI that was saved to a file.
- Main components, functions, classes, or constants with brief technical descriptions: The script opens a hardcoded JSON file path, loads its content, and extracts the `response_text` field. It then attempts to clean this text by stripping whitespace and removing the ` ```json ` markdown wrappers. Finally, it calls `json.loads()` on the cleaned text and prints a success or failure message.
- Important interactions or dependencies with other files or modules: It reads a specific JSON file located in `app/temp/`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a focused unit test for a data parsing issue. It isolates the problematic data and the parsing logic, making it easy to reproduce and debug the issue without making live API calls.
- Special configurations, assets, or third-party libraries if present: Uses the standard `json` library.

FILE: testworthy-pro-dev/testworthy-pro-backend/start.sh
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/start.sh
- Purpose or role in the project: This is a shell script for setting up and starting the backend server in a Linux/macOS environment. It automates the process of setting up a virtual environment, installing dependencies, and running the application.
- Main components, functions, classes, or constants with brief technical descriptions: The script performs a sequence of commands:
1. Checks for a `venv` directory and creates a Python virtual environment if it doesn't exist.
2. Activates the virtual environment using `source venv/bin/activate`.
3. Installs dependencies using `pip install -r requirements.txt`.
4. Checks for a `.env` file and copies it from `.env.example` if missing, then exits to let the user configure it.
5. Runs `alembic upgrade head` to apply database migrations.
6. Starts the Uvicorn server with `reload` enabled.
- Important interactions or dependencies with other files or modules: It interacts with `requirements.txt` for dependencies, `.env.example` and `.env` for configuration, Alembic for migrations, and `app.main:app` to start the server.
- Notable implementation details, architectural patterns, or non-trivial techniques: The script is a convenient wrapper that automates the entire local setup and run process described in `run.mD`. The check for the `.env` file is a good practice to prevent the application from running with default, insecure configurations.
- Special configurations, assets, or third-party libraries if present: Requires a Bash-compatible shell, Python3, and pip.

FILE: testworthy-pro-dev/testworthy-pro-backend/test_json_parsing.py
- File name and relative path: testworthy-pro-dev/testworthy-pro-backend/test_json_parsing.py
- Purpose or role in the project: This is a sophisticated debugging script designed to test and validate the JSON parsing logic for Vertex AI responses, which are known to sometimes be malformed.
- Main components, functions, classes, or constants with brief technical descriptions:
- `parse_vertex_response`: A function that encapsulates the full cleaning and parsing logic. It performs a multi-step cleaning process: removes markdown wrappers, uses regex to extract the main JSON object, cleans control characters from within strings while preserving structural whitespace, removes comments, and fixes common syntax errors like trailing commas or missing commas between objects. It then attempts to parse the cleaned string.
- `main`: The main function that loads a specific saved AI response from a file and passes its content to the `parse_vertex_response` function, printing detailed logs at each step of the process.
- Important interactions or dependencies with other files or modules: It reads a specific file from `app/temp/`. The logic in `parse_vertex_response` is intended to mimic and test the logic found in the `EnhancedChunkProcessor`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This script is an excellent example of defensive programming against unreliable data sources (LLMs). The multi-stage cleaning process is very robust, handling many common ways an LLM can fail to produce perfect JSON. The character-by-character loop to clean control characters only within strings is particularly clever, as it avoids stripping important whitespace from the JSON structure itself.
- Special configurations, assets, or third-party libraries if present: Uses standard Python libraries `json` and `re`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/README.md
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/README.md
- Purpose or role in the project: This is a basic README file for the frontend part of the application, "TestWorthy 2 - Hassan".
- Main components, functions, classes, or constants with brief technical descriptions: It provides minimal information. It links to a Figma design file for the project. It gives two basic commands for running the code: `npm i` to install dependencies and `npm run dev` to start the development server.
- Important interactions or dependencies with other files or modules: It refers to the project's `package.json` file indirectly, as `npm i` and `npm run dev` are commands that use it.
- Notable implementation details, architectural patterns, or non-trivial techniques: None.
- Special configurations, assets, or third-party libraries if present: None mentioned, but implies a Node.js/npm-based project.

FILE: testworthy-pro-dev/testworthy-pro-frontend/env.d.ts
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/env.d.ts
- Purpose or role in the project: This is a TypeScript declaration file. Its purpose is to provide type safety for environment variables accessed via `import.meta.env`, which is a feature of the Vite build tool.
- Main components, functions, classes, or constants with brief technical descriptions: It defines an interface `ImportMetaEnv` which declares the type of `VITE_API_BASE` as a `readonly string`. It then extends the global `ImportMeta` interface to include this typed `env` property.
- Important interactions or dependencies with other files or modules: This file allows TypeScript to understand the structure of `import.meta.env`, preventing type errors and providing autocompletion when developers access `import.meta.env.VITE_API_BASE` elsewhere in the frontend code.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard practice in modern TypeScript projects that use Vite for managing environment variables.
- Special configurations, assets, or third-party libraries if present: This is a configuration file for TypeScript in a Vite project.

FILE: testworthy-pro-dev/testworthy-pro-frontend/index.html
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/index.html
- Purpose or role in the project: This is the main HTML entry point for the frontend single-page application (SPA), built with Vite.
- Main components, functions, classes, or constants with brief technical descriptions: It's a standard HTML5 document. The `<head>` section sets the character set, viewport, title ("TestWorthy Pro"), and links to various favicon formats. The `<body>` contains a single `div` with the ID `root`, which is the mounting point for the React application. A `<script>` tag at the end loads the main JavaScript module (`/src/main.tsx`), which will bootstrap the React app.
- Important interactions or dependencies with other files or modules: This file is the root of the frontend application. It loads the compiled JavaScript from `/src/main.tsx`. It also references favicon assets in the `/public` directory.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a typical minimal `index.html` for a Vite + React project.
- Special configurations, assets, or third-party libraries if present: The file references favicon assets (`/favicon.svg`, `/favicon-32x32.png`, etc.).

FILE: testworthy-pro-dev/testworthy-pro-frontend/package-lock.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/package-lock.json
- Purpose or role in the project: This is the lockfile for the frontend's Node.js dependencies, ensuring reproducible builds by locking the exact versions of all installed packages.
- Main components, functions, classes, or constants with brief technical descriptions: The file is a large JSON object with `lockfileVersion: 3`. The `packages` object lists all dependencies and devDependencies from `package.json` along with their entire dependency trees. Notable dependencies locked in this file include: `@radix-ui/*` components (for UI primitives), `@tanstack/react-query` (for data fetching and caching), `class-variance-authority` and `tailwind-merge` (for styling utilities), `lucide-react` (icons), `react` and `react-dom`, `recharts` (for charts), `sonner` (notifications), `vite`, `tailwindcss`, and `typescript`. It includes a very large number of `@esbuild/*` and `@swc/*` optional dependencies for different operating systems and architectures, which are part of the Vite and SWC build toolchains.
- Important interactions or dependencies with other files or modules: This file is generated and used by `npm` in conjunction with `package.json`.
- Notable implementation details, architectural patterns, or non-trivial techniques: The file shows a dependency on a wide range of modern frontend libraries, indicating the use of a design system (shadcn/ui, which uses Radix), a data-fetching layer (React Query), and a modern build tool (Vite with SWC).
- Special configurations, assets, or third-party libraries if present: Lists a large number of npm packages.

FILE: testworthy-pro-dev/testworthy-pro-frontend/package.json
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/package.json
- Purpose or role in the project: This is the manifest file for the frontend Node.js project. It lists the project's dependencies, development dependencies, and defines scripts for running and building the application.
- Main components, functions, classes, or constants with brief technical descriptions:
- `dependencies`: Lists runtime dependencies, including many `@radix-ui/*` packages for UI components, `@tanstack/react-query` for server state management, `class-variance-authority`, `clsx`, and `tailwind-merge` for styling, `lucide-react` for icons, `react`, `react-dom`, `recharts` for charting, and others.
- `devDependencies`: Lists development dependencies, including `@types/node`, `@vitejs/plugin-react-swc`, `autoprefixer`, `postcss`, `tailwindcss`, and `vite`.
- `scripts`: Defines two scripts: `dev` (which runs `vite`) to start the development server, and `build` (which runs `vite build`) to create a production build of the application.
- Important interactions or dependencies with other files or modules: This file is central to the frontend's build and dependency management process. It is used by `npm` to install packages and run scripts.
- Notable implementation details, architectural patterns, or non-trivial techniques: The dependency list points to a modern React stack using Vite as the build tool (instead of Create React App or Next.js), SWC for fast compilation, Tailwind CSS for styling, and shadcn/ui (indicated by the Radix UI packages and `class-variance-authority`) for its component library.
- Special configurations, assets, or third-party libraries if present: This file defines the entire frontend technology stack.

FILE: testworthy-pro-dev/testworthy-pro-frontend/public/favicon-placeholder.txt
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/public/favicon-placeholder.txt
- Purpose or role in the project: This is a placeholder file indicating where the application's favicon should be placed.
- Main components, functions, classes, or constants with brief technical descriptions: It is a text file containing a comment that explains that the actual `favicon.ico` file should be placed in the `public` directory.
- Important interactions or dependencies with other files or modules: This file is referenced implicitly by the `index.html` file, which expects favicons to be in the public directory.
- Notable implementation details, architectural patterns, or non-trivial techniques: None.
- Special configurations, assets, or third-party libraries if present: This is a placeholder for an asset.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/App.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/App.tsx
- Purpose or role in the project: This is the root component of the React frontend application. It handles routing, authentication state, and renders the main layout including the header, sidebar, and the active module.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses `useState` to manage the application's top-level state, including `activeModule`, `selectedProjectId`, `isAuthenticated`, `currentUser`, etc.
- Routing: Implements a client-side routing logic. `parseCurrentRoute` parses the `window.location` to determine the initial state. `updateURL` uses `window.history.pushState` to change the URL without a page reload when the user navigates. A `popstate` event listener handles browser back/forward buttons.
- Authentication: An `useEffect` hook runs on startup to check for authentication tokens in `localStorage` and validate the session with the backend using `validateSession`. It also provides `handleLogin`, `handleSignUp`, and `handleLogout` functions to manage the auth state.
- Code Splitting: Uses `React.lazy` to lazy-load heavier components (`TestCaseDetailsModule`, `TestRunDetailsModule`, etc.) to improve initial page load performance. A `Suspense` component with a `ModuleLoader` fallback is used to handle the loading state.
- Component Rendering: A `renderActiveModule` function contains a `switch` statement that renders the correct component based on the `activeModule` state variable.
- Important interactions or dependencies with other files or modules: This component imports and renders almost all other major components, including `Header`, `Sidebar`, and all the module components. It uses auth service functions from `src/services/auth.ts`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This file implements a custom, simple client-side router based on URL parsing and the History API. This is an alternative to using a dedicated routing library like React Router. The use of `React.lazy` and `Suspense` is a key performance optimization pattern (code splitting).
- Special configurations, assets, or third-party libraries if present: Uses React.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/Attributions.md
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/Attributions.md
- Purpose or role in the project: This markdown file provides attribution for third-party assets used in the project.
- Main components, functions, classes, or constants with brief technical descriptions: It states that the project includes components from `shadcn/ui` used under the MIT license and photos from `Unsplash` used under their license.
- Important interactions or dependencies with other files or modules: None.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard practice for legal compliance and giving credit to open-source and creative commons assets.
- Special configurations, assets, or third-party libraries if present: Mentions `shadcn/ui` and `Unsplash`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/Header.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/Header.tsx
- Purpose or role in the project: This is a React component that renders the main header of the application.
- Main components, functions, classes, or constants with brief technical descriptions:
- `Header` component: The main functional component. It receives `currentUser` and `onLogout` as props.
- State: Uses `useState` to manage the current theme ('light' or 'dark').
- Theme Toggle: An `useEffect` hook fetches the user's saved theme preference from the backend (`/api/v1/users/me`). The `toggleTheme` function switches the theme, applies the 'dark' class to the `<html>` element, and makes an API call to save the user's preference.
- UI Components: It uses components from a UI library (likely shadcn/ui), including `Button`, `Avatar`, and `DropdownMenu`. It displays the application logo and name, a notification bell, and a user profile dropdown. The dropdown contains options for profile settings, theme toggling, and logging out.
- Helper Functions: `getUserInitials` and `getDisplayName` are used to format the user's name for display in the avatar and dropdown.
- Important interactions or dependencies with other files or modules: It interacts with the backend user API via `makeAuthenticatedRequest` to fetch and save the theme preference. It calls the `onLogout` function passed down from `App.tsx` when the logout button is clicked.
- Notable implementation details, architectural patterns, or non-trivial techniques: The theme management is well-implemented, fetching the user's preference from the server, applying it client-side by toggling a CSS class on the root element, and persisting changes back to the server.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons, `sonner` for toast notifications, and custom UI components.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/Sidebar.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/Sidebar.tsx
- Purpose or role in the project: This React component renders the main navigation sidebar for the application.
- Main components, functions, classes, or constants with brief technical descriptions:
- `Sidebar` component: The main functional component. It receives `activeModule`, `onModuleChange` (a callback function), and `userRole` as props.
- Navigation Data: Defines `navigationItems` and `settingsItems` as arrays of objects, each representing a link in the sidebar with an `id`, `label`, and `icon`.
- Rendering Logic: It maps over these arrays to render a list of `Button` components. The currently active item is styled differently based on the `activeModule` prop. Clicking a button calls the `onModuleChange` callback to notify the parent `App` component to switch the view.
- Role-Based Access Control (RBAC): It includes logic to hide the 'User Management' and 'Master Prompts' links for users whose `userRole` is not 'admin'.
- Important interactions or dependencies with other files or modules: This is a presentational component controlled by its parent, `App.tsx`. It calls the `onModuleChange` prop to trigger navigation.
- Notable implementation details, architectural patterns, or non-trivial techniques: The implementation of RBAC directly in the rendering logic is a simple but effective way to control UI visibility based on user permissions. The component is cleanly structured, separating navigation data from the rendering logic.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons and custom UI components like `Button`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/auth/Login.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/auth/Login.tsx
- Purpose or role in the project: This is a React component that renders the user login form.
- Main components, functions, classes, or constants with brief technical descriptions:
- `Login` component: The main functional component. It receives `onLogin` and `onSwitchToSignup` callback props.
- State: Uses `useState` to manage the `username`, `password`, `showPassword` toggle, and `isLoading` state.
- `handleLogin`: This function is called on form submission. It prevents the default form action, performs basic validation, sets `isLoading` to true, and calls the `apiLogin` service. On success, it fetches the user's profile to get their role and display name, then calls the `onLogin` prop. On failure, it displays an error toast.
- UI: The component is built using custom UI components like `Card`, `Button`, `Input`, and `Label`. It includes a "show password" toggle for usability. It also displays hardcoded demo credentials for convenience.
- Important interactions or dependencies with other files or modules: It uses the `login` function from `src/services/auth.ts` to make the API call. It calls the `onLogin` prop (passed from `App.tsx`) to update the application's authentication state.
- Notable implementation details, architectural patterns, or non-trivial techniques: After a successful login, it makes a second API call to `/api/v1/users/me` to fetch the user's full profile details (like role and name). This is a common pattern to keep the login response minimal and fetch detailed user data separately.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons and `sonner` for toast notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/auth/SignUp.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/auth/SignUp.tsx
- Purpose or role in the project: This is a React component that renders the user registration form.
- Main components, functions, classes, or constants with brief technical descriptions:
- `SignUp` component: The main component, which receives `onSignUp` and `onSwitchToLogin` callbacks.
- State: Uses `useState` to manage a `formData` object containing all form fields (`fullName`, `email`, `username`, `password`, etc.), and toggles for showing passwords.
- `handleSignUp`: This function handles form submission. It performs validation checks for required fields, password length, password confirmation, and email format. If validation passes, it calls the `onSignUp` prop and shows a success toast. It does not appear to make an API call itself, relying on the parent component to handle the registration logic.
- UI: The form is built using custom UI components like `Card`, `Input`, `Select`, and `Button`. It has a multi-column layout for the form fields and includes password visibility toggles.
- Important interactions or dependencies with other files or modules: It calls the `onSignUp` prop passed from `App.tsx` upon successful validation.
- Notable implementation details, architectural patterns, or non-trivial techniques: The form state is managed in a single `formData` object, which is a common pattern for handling forms in React.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons and `sonner` for notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/figma/ImageWithFallback.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/figma/ImageWithFallback.tsx
- Purpose or role in the project: This is a React component that provides an image with a fallback. If the primary image source (`src`) fails to load, it displays a default error image instead of a broken image icon.
- Main components, functions, classes, or constants with brief technical descriptions:
- `ImageWithFallback` component: A functional component that wraps the standard `<img>` tag.
- State: It uses a `useState` hook with a boolean `didError` to track whether the image has failed to load.
- `handleError`: A function that sets `didError` to `true`. This function is passed to the `onError` event handler of the `<img>` tag.
- Rendering Logic: It uses a conditional render. If `didError` is `false`, it renders the normal `<img>` tag with the provided `src`. If `didError` is `true`, it renders a `div` containing an `<img>` tag whose `src` is set to `ERROR_IMG_SRC`.
- `ERROR_IMG_SRC`: A constant containing a base64-encoded SVG data URI for the fallback image.
- Important interactions or dependencies with other files or modules: This is a self-contained utility component.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard and effective pattern for handling broken images in React. By using the `onError` event, it can gracefully degrade the UI when an image asset is missing or fails to load. The original failed URL is preserved in a `data-original-url` attribute on the fallback for debugging purposes.
- Special configurations, assets, or third-party libraries if present: Uses React.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/integrations/GitHubIntegrationDashboard.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/integrations/GitHubIntegrationDashboard.tsx
- Purpose or role in the project: This is a React component that provides a dashboard for managing and viewing the GitHub integration for a specific project.
- Main components, functions, classes, or constants with brief technical descriptions:
- State: Manages extensive state using `useState`, including lists of `repositories`, `prAnalyses`, `testDeltas`, and `integrationLogs`, as well as UI state for modals, loading, and selected items.
- Data Fetching: Uses `useEffect` to call `loadData` on component mount, which fetches all necessary information from the backend repository and PR analysis endpoints using `makeAuthenticatedRequest`.
- API Interaction: Contains functions to interact with the backend: `handleConnectRepository` (creates a new repository configuration), `loadTestDeltas` (fetches recommendations for a PR), `applyTestDelta` (applies an AI-suggested change), and `triggerAnalysis` (manually starts a PR analysis).
- UI Rendering: Renders a tabbed interface ('Repositories', 'PR Analyses', 'Integration Logs'). The 'PR Analyses' tab has a two-column layout showing a list of PRs on the left and details of the selected PR on the right, including AI-generated recommendations (`testDeltas`).
- UI Components: Uses custom UI components like `Card`, `Button`, `Badge`, `Tabs`, and `Dialog` to build the interface. It includes helper functions like `getStatusBadge` and `getRiskBadge` to render colored badges based on data values.
- Important interactions or dependencies with other files or modules: This component makes numerous calls to the backend API endpoints defined in `repository_routes.py` and `webhook_routes.py`. It uses `makeAuthenticatedRequest` for authenticated API calls and `showToast` for notifications.
- Notable implementation details, architectural patterns, or non-trivial techniques: The component implements a master-detail view for PR analyses, which is a common UI pattern. It provides a comprehensive interface for the entire self-healing test case workflow, from configuring repositories to viewing and applying AI recommendations.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/milestones/MilestoneModal.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/milestones/MilestoneModal.tsx
- Purpose or role in the project: This is a reusable React component that provides a modal dialog (a popup) for creating or editing a project milestone.
- Main components, functions, classes, or constants with brief technical descriptions:
- `MilestoneModal` component: The main functional component. It receives props like `isOpen`, `onClose`, `projectId`, and an optional `milestone` object.
- State: Uses `useState` to manage the form fields (`name`, `description`, `dueDate`, `status`), loading state (`isLoading`), and error messages.
- Logic: It determines if it's in "edit" or "create" mode based on the presence of the `milestone` prop. The `handleSubmit` function performs validation, then calls either `milestoneService.updateMilestone` or `milestoneService.createMilestone`. On success, it calls the `onMilestoneUpdated` callback and closes the modal.
- UI: Built using custom `Dialog`, `Button`, `Input`, `Label`, and `Textarea` components. It includes a loading spinner in the submit button when an API call is in progress.
- Important interactions or dependencies with other files or modules: It uses the `milestoneService` from `src/services/milestones.ts` to interact with the backend API. It is designed to be used by other components, like `ProjectDetailsModule`, which control its visibility via the `isOpen` prop.
- Notable implementation details, architectural patterns, or non-trivial techniques: This is a classic example of a controlled form component in React. The modal's state is managed internally, but its visibility is controlled by the parent, which is a common and effective pattern.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons and `sonner` for toast notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/AISettings.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/AISettings.tsx
- Purpose or role in the project: This is a large and complex React component that renders the "AI Configuration" page. It allows users to manage their AI provider settings, API keys, and view/edit master prompt templates.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses `useState` extensively to manage the form state for AI settings (provider, model, temperature), lists of providers, API keys, prompts, and UI state (loading, dialogs).
- Data Fetching: An `useEffect` hook calls `loadAISettings` on mount to fetch all necessary configuration data from the backend using the `AISettingsService`.
- Event Handlers:
  - `handleSaveSettings`: Saves the global AI settings (default provider, model, etc.) to the backend.
  - `handleTestProvider`: A placeholder function to test provider connections.
  - Other handlers manage the state of the API key and prompt template forms.
- UI Rendering: The component is divided into three main sections using `Card` components: "AI Provider" (for selecting default model and settings), "API Keys" (for managing credentials), and "Prompt Dictionary" (for viewing and editing prompt templates). The API keys and prompts are displayed in tables. It uses `Dialog` components for adding new API keys.
- Important interactions or dependencies with other files or modules: It relies heavily on the `AISettingsService` to interact with the backend endpoints defined in `ai_settings_routes.py`. It uses many custom UI components from the project's UI library.
- Notable implementation details, architectural patterns, or non-trivial techniques: The component dynamically populates the "Model" dropdown based on the selected "Provider" by filtering the `PROVIDER_MODELS` constant. The component has a significant amount of hardcoded mock data for `apiKeys` and `prompts`, indicating that the backend for these features may not be fully implemented yet.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` and `sonner`. Imports `PROVIDER_MODELS` which is a hardcoded constant mapping providers to their available models.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/AggregateViewerModule.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/AggregateViewerModule.tsx
- Purpose or role in the project: This React component provides a UI for viewing, comparing, and reverting to different historical versions of a project's AI-generated aggregate response.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses `useState` to manage the project data, a list of `versions`, the `selectedVersion`, the `currentAggregate`, and the `displayedAggregate`.
- Data Fetching: An `useEffect` hook calls `loadData` which fetches the project details and all aggregate versions using the `projectService` and `AggregateVersionService`.
- Event Handlers:
  - `handleVersionChange`: Updates the `displayedAggregate` when the user selects a different version from the dropdown.
  - `handleSaveVersion`: Calls the service to create a new snapshot of the current aggregate data.
  - `handleRevert`: Calls the service to replace the current aggregate data with the data from the selected historical version.
- UI Rendering: The main UI consists of a version selector dropdown, buttons for saving and reverting, and a series of collapsible cards (`renderSection`) to display the different parts of the aggregate data (milestones, test plans, etc.). It also includes a raw JSON viewer. `Dialog` components are used for confirming save and revert actions.
- Important interactions or dependencies with other files or modules: This module is a viewer for the `ai_aggregate_response` JSON blob stored on the `Project` model. It interacts with the backend endpoints for managing `ProjectAggregateVersion` entities via the `AggregateVersionService`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This component provides a powerful UI for auditing and managing the history of AI-generated content. The ability to save named versions and revert to them is a key feature for maintaining control over the AI's output. The use of collapsible sections helps manage the large amount of data in the aggregate response.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react`, `sonner`, and custom UI components.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/CoursesModule.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/CoursesModule.tsx
- Purpose or role in the project: This component renders a "Medical Training Courses" dashboard. It seems to be unrelated to the core test management functionality and might be a leftover from a different project template or a feature that was later removed.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses `useState` to manage a list of `coursesData` (which is hardcoded), the currently selected course for a details view, and the visibility of modals.
- UI Rendering: It displays a set of summary statistic cards (Total Courses, Active Courses, etc.), a table listing all the courses, a button to add a new course, and a `Dialog` for viewing course details. The UI is built with custom `Card`, `Table`, `Button`, and `Badge` components.
- Data: All data for courses and trainers is hardcoded directly in the component file. There are no API calls.
- Important interactions or dependencies with other files or modules: This component is self-contained and does not appear to interact with any services or other modules related to the TestWorthy application.
- Notable implementation details, architectural patterns, or non-trivial techniques: The component is a good example of a static dashboard layout, but its content (medical training) is incongruous with the rest of the application (software test management).
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` and custom UI components.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/CreateProjectWizard.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/CreateProjectWizard.tsx
- Purpose or role in the project: This is a complex, multi-step modal dialog component for creating a new project, either manually or using an AI-powered import from a codebase.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses a large number of `useState` hooks to manage the wizard's state, including the `currentStep`, `setupMethod` ('manual' or 'ai'), project details, and arrays for manually added milestones, plans, suites, etc. It also has extensive state for the AI import process, such as the `uploadedFile`, `tokenEstimation`, `aiImportResults`, and the state of the chunking workflow.
- Wizard Logic: The UI is a step-by-step wizard. `handleNext` and `handleBack` functions increment or decrement the `currentStep`. The content for each step is rendered by the `renderStepContent` function using a `switch` statement.
- Manual Flow: If `setupMethod` is 'manual', the wizard presents a series of forms for the user to input project details, milestones, test plans, suites, cases, and runs.
- AI Flow: If `setupMethod` is 'ai', the wizard guides the user through uploading a file (ZIP, code files, or documents), reviewing the extracted content, and then orchestrating a multi-step AI processing workflow (Analyze, Prepare Chunks, Process Chunks, Aggregate Results).
- `handleCreateProject`: The final function that gathers all the data from the wizard's state and makes API calls using various services (`projectService`, `milestoneService`, etc.) to create all the entities in the database.
- Important interactions or dependencies with other files or modules: This component is a major feature. It interacts with nearly all the data creation services (`projectService`, `milestoneService`, `testPlanService`, `testSuiteService`, `TestCaseService`, `TestRunService`). For the AI flow, it uses `AIProjectImportService` and `ZipParserService`.
- Notable implementation details, architectural patterns, or non-trivial techniques: This component implements the "Wizard" UI pattern. The AI processing flow is particularly complex, breaking down a potentially long-running task into user-controlled steps (Analyze, Prepare, Process, Aggregate), providing feedback and progress at each stage. This is a much better user experience than a single "process" button with a long, indeterminate wait time.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react`, `sonner`, and many custom UI components.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/DashboardModule.tsx
- File name and relative path: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/DashboardModule.tsx
- Purpose or role in the project: This component renders the main dashboard view, displaying a high-level overview of testing activities and project health.
- Main components, functions, classes, or constants with brief technical descriptions:
- State Management: Uses `useState` to store `dashboardData`, loading state, and error state.
- Data Fetching: An `useEffect` hook calls `dashboardService.getDashboardStats()` on component mount to fetch all the necessary data from the backend.
- Data Processing: Contains several helper functions to process the fetched data for display: `getTestMetrics` calculates pass/fail/pending counts and pass rate. `getRecentProjects` and `getRecentTestRuns` filter the `recent_activity` array. `getProjectHealthChartData` and `getExecutionStatsChartData` format data for use with the `recharts` library.
- UI Rendering: The component displays a welcome message, a grid of key test metrics, lists of recent projects and test runs, and charts for project health and execution status distribution.
- Important interactions or dependencies with other files or modules: It uses `dashboardService` to fetch data from the `/dashboard/stats` backend endpoint. It calls the `onNavigate` prop to handle navigation to other modules (e.g., clicking 'View All Projects').
- Notable implementation details, architectural patterns, or non-trivial techniques: The dashboard effectively visualizes complex data using a combination of statistic cards, lists, and charts. It demonstrates how to consume an aggregated data endpoint from the backend and transform it into various UI elements.
- Special configurations, assets, or third-party libraries if present: Uses `lucide-react` for icons and `recharts` for rendering charts (`BarChart`, `PieChart`).

--- CHUNK SEPARATOR ---

FILE: (incomplete)
Purpose or role in the project: This is an incomplete JSX snippet, likely from a dashboard component. Its purpose is to display a "Recent Activity" card if there is any recent activity data available.
Main components, functions, classes, or constants with brief technical descriptions: The snippet uses several custom UI components: `Card`, `CardHeader`, `CardTitle`, and `CardContent`. It conditionally renders this card based on `dashboardData && dashboardData.recent_activity.length > 0`. Inside the card, it maps over the first 5 items of the `dashboardData.recent_activity` array to display individual activity items. Each item shows a title, a formatted timestamp using a `formatTimeAgo` function (not defined in the snippet), and the entity type.
Important interactions or dependencies with other files or modules: It depends on a `dashboardData` prop or state variable, which would be fetched from a service. It also uses a `formatTimeAgo` utility function. The `Activity` icon is imported from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques: The code uses conditional rendering to only show the section if data exists. It uses `.slice(0, 5)` to limit the number of displayed items. A unique `key` is generated for each item in the map using a combination of `entity_type` and `id` to ensure stable rendering.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/HealTestCaseModule.tsx
Purpose or role in the project: This file contains a React component that provides a user interface for "healing" a test case using AI. It allows users to submit a request to fix a test case, and then view a side-by-side comparison of the original and AI-healed versions of both the test case and its associated aggregate data structure.
Main components, functions, classes, or constants with brief technical descriptions:
- `HealTestCaseModule`: The main React functional component. It manages the entire healing workflow.
- State variables: Manages component state using `useState`, including the original test case (`testCase`), project details (`project`), loading and healing status flags (`loading`, `healing`), AI-generated results (`healedData`), UI view mode (`viewMode`), and AI configuration (provider, model, token count, user request).
- `useEffect` hooks: Used to load initial data (`loadData` function) when the component mounts, and to log detailed debugging information whenever `healedData` is updated.
- `loadData`: An asynchronous function that fetches test case and project details using `TestCaseService` and `projectService`.
- `handleProviderChange`, `handleModelChange`: Event handlers for the AI provider and model selection dropdowns. `handleProviderChange` also sets default models and token counts based on the selected provider.
- `handleStartHealing`: An async function that validates the user's request and calls `AIHealingService.healTestCase` to initiate the AI healing process. It handles UI state changes and displays toasts on success or failure.
- `handleApplyChanges`: An async function that calls `AIHealingService.saveHealedTestCase` to persist the healed data to the backend and then navigates the user back to the test case details view.
- `renderDiffField`: A rendering helper function that creates a side-by-side comparison for individual text fields (like title, description), showing "Original" and "Healed" versions. It only renders if a change exists.
- `renderAggregateDiff`: A complex rendering function that generates a detailed, line-by-line diff view for JSON aggregate data. It highlights added, removed, and modified lines with different colors and icons. It also performs a word-level diff within modified lines to pinpoint exact changes.
Important interactions or dependencies with other files or modules:
- It heavily relies on services: `AIHealingService` for healing logic, `AISettingsService` for provider/model constants, `TestCaseService` and `projectService` for fetching initial data.
- It uses custom UI components like `Button`, `Card`, `Select`, `Textarea`, and `Input` from the `../ui` directory.
- It uses `lucide-react` for icons and `sonner` for displaying toast notifications.
- It interacts with parent components via the `onNavigate` prop to change the application view.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component follows a two-stage UI pattern: first, a configuration form, and second, a results/comparison view, conditionally rendered based on the presence of `healedData`.
- The `renderAggregateDiff` function is a sophisticated implementation of a visual JSON diff viewer, calculating changes line-by-line and word-by-word.
- An extensive `useEffect` hook is used for debugging purposes, performing deep comparisons of the received `healedData` object and logging the results to the console. This is a good practice for complex data structures.
Special configurations, assets, or third-party libraries if present: Third-party libraries include `react`, `lucide-react`, and `sonner`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/Integrations.tsx
Purpose or role in the project: This component serves as the main interface for managing integrations with external services such as Jira, GitHub, and Slack. It allows users to connect, disconnect, and configure settings for these integrations.
Main components, functions, classes, or constants with brief technical descriptions:
- `Integrations`: The primary functional React component.
- State Management: Uses `useState` hooks to manage dialog visibility (`showConnectDialog`, `showConfigDialog`), the currently selected integration, connection status (`isConnecting`), form data for credentials (e.g., `githubToken`, `githubRepo`), and the list of `connectedRepos`.
- `loadConnectedRepos`: An async function that fetches connected repositories from the `/api/v1/repositories` endpoint on component mount using `makeAuthenticatedRequest`.
- `integrations`: A hardcoded array of objects defining available integrations, including their name, description, category, and icon. The `connected` status for GitHub is dynamically calculated based on the `connectedRepos` state.
- `groupedIntegrations` and `categoryIcons`: Data structures used to group and display integrations by category with corresponding icons.
- Event Handlers:
  - `handleConnect`: Opens the credential entry dialog for a selected integration.
  - `handleConfigure`: Opens a configuration dialog for an already connected integration, pre-populating it with existing settings.
  - `handleDisconnect`: Initiates the disconnection process by sending a DELETE request to the backend.
  - `handleGitHubConnect`: Handles the specific logic for connecting to GitHub, including parsing the repository URL, creating the configuration payload, and sending a POST request.
  - `handleSaveConfiguration`: Saves updated configuration settings for an integration via a PUT request.
  - `handleTestConnection`: A placeholder to simulate testing an integration's connection.
- `getWebhookUrl`: A utility function to generate the correct webhook URL for a given repository.
Important interactions or dependencies with other files or modules:
- Interacts with the backend via `makeAuthenticatedRequest` from `../../services/auth` to fetch, create, update, and delete repository configurations.
- Uses the `showToast` utility from `../ui/Toast` for user notifications.
- Utilizes a suite of custom UI components from `../ui` including `Card`, `Button`, `Badge`, `Dialog`, `Input`, `Label`, and `Switch`.
- Uses `lucide-react` for icons.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component dynamically determines the connection status of integrations by fetching a list of connected repositories from the backend and comparing it against the statically defined list of available integrations.
- The GitHub connection logic includes client-side validation and parsing of the repository URL to extract the owner and repo name.
- It employs separate dialogs for connecting (entering credentials) and configuring (adjusting settings), providing a clear separation of concerns.
- Only the GitHub connection logic (`handleGitHubConnect`) is fully implemented; other integrations are placeholders that show a "coming soon" message.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/MasterPrompts.tsx
Purpose or role in the project: This file defines a React component for managing a library of "Master Prompts" used by the application's AI features. It provides a UI to view, create, edit, and delete prompts, with a distinction between global (system-wide) and user-specific prompts.
Main components, functions, classes, or constants with brief technical descriptions:
- `MasterPrompts`: The main functional React component.
- `Prompt` interface: Defines the structure for a prompt object, including properties like `id`, `name`, `template`, `category`, `type` ('global' or 'user'), and placeholders.
- State Management: Uses `useState` hooks to manage a list of `prompts` (currently mock data), filter and search states (`searchTerm`, `filterType`, `filterCategory`), dialog visibility, and the currently selected prompt. A `currentUserRole` state variable is used to simulate role-based access control (RBAC).
- `filteredPrompts`: A derived array that filters the main `prompts` list based on active search and filter criteria.
- `canEdit` and `canDelete`: Helper functions that implement business logic for permissions. An admin can edit global prompts, while a user can only edit or delete their own user-specific prompts.
- UI Structure: The component renders a header, a banner explaining permissions based on the simulated user role, statistics cards (total, global, user prompts), a filter bar, and a main table displaying the list of prompts. Actions like view, edit, and delete are conditionally rendered in the table based on permissions.
- Dialogs: Utilizes `Dialog` components for viewing prompt details, editing an existing prompt, and creating a new user-specific prompt. The forms within these dialogs are controlled components.
Important interactions or dependencies with other files or modules:
- It relies on custom UI components from the `../ui` directory, such as `Card`, `Button`, `Input`, `Select`, `Badge`, `Dialog`, and `Table`.
- Uses icons from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component is currently based on mock data stored in the `prompts` state variable. In a production environment, this data would be fetched from a backend service.
- It demonstrates a clear implementation of Role-Based Access Control (RBAC) on the frontend by conditionally rendering action buttons (`Edit`, `Trash2`) based on the `canEdit` and `canDelete` functions, which check the user's role and ownership of the prompt.
- The user creation form automatically prefixes the prompt name with the username ('johndoe'), enforcing a naming convention for user prompts.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/ProjectDetailsModule.tsx
Purpose or role in the project: This is a central, multi-faceted component that serves as the main dashboard for a single project. It uses a tabbed layout to organize and manage all entities related to the project, including milestones, test plans, test suites, test cases, test runs, integrations, and AI-generated project information.
Main components, functions, classes, or constants with brief technical descriptions:
- `ProjectDetailsModule`: The main React functional component.
- State Management: Employs extensive state management using `useState` and `useEffect` to handle the project object itself, plus separate states for lists, loading status, and errors for each entity type (milestones, test plans, etc.). It also manages the state for numerous modals and dialogs used for CRUD operations.
- Data Fetching: Uses a lazy-loading strategy. The main project data is fetched on mount via `loadProject`. Data for other tabs (e.g., `loadMilestones`, `loadTestPlans`) is fetched when the corresponding tab is first activated or if the data is not yet loaded. Pagination is implemented for fetching test cases (`loadTestCases`) to handle large datasets efficiently.
- CRUD Handlers (`handleCreate...`, `handleEdit...`, `handleDelete...`): A comprehensive set of functions that trigger modals for creating/editing entities or confirmation dialogs for deletion. They interact with their respective services and then call the appropriate `load...` function to refresh the UI.
- Modal Integration: Renders and controls various modal components (`MilestoneModal`, `TestPlanModal`, `TestSuiteModal`, `TestCaseModal`, `TestRunModal`) for CRUD operations.
- Tabbed Interface (`Tabs` component): The primary organizational structure. The active tab is controlled via the `activeTab` prop and changes are communicated to the parent via the `onNavigate` callback.
- AI Info Tab: A special tab, conditionally rendered for AI-generated projects (`project?.ai_generated`). It displays the raw AI aggregate response using a `JsonViewer` component and integrates the `AggregateVersionManager` for version history and restoration.
- Integrations Tab: Renders the `GitHubIntegrationDashboard` component for managing project-specific integrations.
- Project Management Dialogs: Includes dialogs for renaming the project, deleting the project, and managing project members (add/remove).
Important interactions or dependencies with other files or modules:
- Service Dependencies: This component is a major consumer of backend services, interacting with `projectService`, `ProjectMemberService`, `milestoneService`, `testPlanService`, `testSuiteService`, `TestCaseService`, and `TestRunService`.
- Component Dependencies: It uses a large number of custom UI components from `../ui`, and integrates several complex child components like `MilestoneModal`, `TestPlanModal`, `TestSuiteModal`, `TestCaseModal`, `TestRunModal`, `AggregateVersionManager`, `JsonViewer`, and `GitHubIntegrationDashboard`.
- Navigation: It uses the `onNavigate` prop to handle internal tab switching and navigation to other detailed views like `test-case-details`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- It functions as a "smart" container component, orchestrating data fetching and state for a large number of related but distinct sub-sections.
- The lazy-loading of tab content is an important performance optimization.
- The component handles pagination for test cases, demonstrating how to manage large lists of data.
- The "AI Info" tab provides a unique "under-the-hood" view of AI-generated projects, linking the user-facing test entities back to the structured data that created them. This includes version control for the entire AI-generated project structure.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/ProjectsModule.tsx
Purpose or role in the project: This component serves as the main project listing page, displaying all available projects in a grid of cards. It provides a high-level overview of each project's status and statistics and includes the functionality to launch the project creation wizard.
Main components, functions, classes, or constants with brief technical descriptions:
- `ProjectsModule`: The main functional React component, which takes an `onNavigate` function prop for handling navigation.
- State Management: Uses `useState` hooks to manage the `projects` array, the visibility of the creation wizard (`isWizardOpen`), and data fetching states (`isLoading`, `loadError`).
- `loadProjects`: An asynchronous function that fetches all projects along with their statistics using `projectService.getProjectsWithStats()`. It is called once on component mount and handles setting loading and error states.
- `handleProjectCreated`: A callback function passed to the `CreateProjectWizard` component. When a new project is created, this function optimistically adds the new project to the beginning of the `projects` state array, updating the UI instantly without needing a full refetch.
- `CreateProjectWizard`: A child component rendered as a modal, responsible for the multi-step process of creating a new project.
- Rendering Logic: The component implements a clear state-driven rendering flow. It shows a skeleton loading UI while `isLoading` is true. If an error occurs, it displays an error message. If no projects are found, it shows an empty state with a "Create Project" call-to-action. Otherwise, it maps over the `projects` array to render each project as a `Card`.
Important interactions or dependencies with other files or modules:
- It interacts with `projectService` to fetch project data.
- It uses the `CreateProjectWizard` component to handle project creation.
- Navigation to a specific project's details is handled by calling the `onNavigate` prop with the page 'project-details' and the `projectId`.
- It uses custom UI components like `Card`, `Button`, and `Badge`, and icons from `lucide-react`.
- It uses `showToast` for displaying error notifications.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The use of a skeleton loader during data fetching provides a better user experience than a simple loading spinner.
- The optimistic UI update in `handleProjectCreated` makes the application feel more responsive after a user creates a new project.
- The data fetched includes pre-calculated statistics (`ProjectWithStats`), meaning the frontend does not have to compute these values itself, which is an efficient design.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/Reports.tsx
Purpose or role in the project: This component provides a user interface for viewing and generating reports on testing activities. It includes a table of recent reports and a section for quickly generating predefined report types.
Main components, functions, classes, or constants with brief technical descriptions:
- `Reports`: The main functional React component.
- State Management: Uses `useState` to manage the state of filters for project, report type, and date range (`filterProject`, `filterType`, `filterDateRange`).
- Mock Data: The component is currently built with hardcoded mock data for `recentReports` and `reportTypes`. This indicates it is not yet connected to a backend service for report data.
- UI Structure: The layout consists of a main header with a "Generate Report" button, a `Card` containing filter dropdowns, a `Card` containing a table of recent reports with pagination controls, and a final section with a grid of cards for "Quick Report Generation".
- Filtering UI: Provides `Select` components for filtering but the actual filtering logic on the `recentReports` data is not implemented.
Important interactions or dependencies with other files or modules:
- It relies on custom UI components from the `../ui` directory, including `Card`, `Button`, `Input`, `Select`, and `FileText`.
- It uses icons from the `lucide-react` library.
- There are no interactions with backend services; all data is mocked locally.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component serves as a UI-complete but non-functional placeholder for a future reporting feature.
- The "Quick Report Generation" section uses placeholder bar charts created with styled divs, demonstrating the intended look and feel before a real charting library is integrated for this specific view.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/ScheduleModule.tsx
Purpose or role in the project: This component is a module for managing a training schedule, seemingly for a medical training application. It provides a calendar-like view of sessions, a list of upcoming sessions, and functionality to schedule new sessions. Its content is thematically different from the main test management application.
Main components, functions, classes, or constants with brief technical descriptions:
- `ScheduleModule`: The main functional React component.
- Mock Data: The component is entirely driven by hardcoded constant arrays: `calendarData`, `upcomingSessions`, `trainers`, `branches`, and `courses`. This suggests it is either a template, an example, or part of an unrelated feature set.
- State Management: Uses `useState` to manage UI state, including the selected date, view mode (day/week/month), filter values for branch and trainer, and the state for the "Add Session" dialog (`isAddSessionOpen` and `newSession` form data).
- Helper Functions: `getStatusBadge` and `getTypeBadge` return styled `Badge` components based on the session's status or type, demonstrating conditional styling.
- UI Structure: The layout includes a header with a "Schedule Session" button, statistics cards, and a two-column grid containing the main session list and a sidebar for upcoming sessions. It also features a "Weekly Schedule Overview" card at the bottom.
- Dialogs: A `Dialog` component is used to house the form for scheduling a new session.
Important interactions or dependencies with other files or modules:
- It uses custom UI components from the `../ui` directory such as `Card`, `Button`, `Input`, `Select`, `Badge`, and `Dialog`.
- Icons are imported from `lucide-react`.
- There are no dependencies on backend services.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component is a self-contained UI demonstration using only mock data. The "calendar" is not a true calendar grid but a filtered list of session data.
- The thematic focus on medical training (doctors, courses like "Advanced Cardiology") is a significant deviation from the software testing theme of other modules like `ProjectsModule` and `TestCaseDetailsModule`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/TestCaseDetailsModule.tsx
Purpose or role in the project: This is a highly detailed and feature-rich component for viewing and interacting with a single test case. It serves as both a detailed information view and an execution interface when accessed from a test run. It supports editing, version history, attachments, comments, defect logging, and AI-powered healing.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseDetailsModule`: The main functional component.
- State Management: Uses an extensive set of `useState` and `useEffect` hooks to manage component state, including the test case data, related project entities (suites, milestones, members), versions, comments, activities, defects, attachments, UI modes (loading, edit mode), dialog visibility, and form data for various actions.
- Data Fetching: A primary `useEffect` hook orchestrates the fetching of all required data from multiple backend services upon component mount, using services like `TestCaseService`, `testSuiteService`, `milestoneService`, etc.
- Version Control: Implements a version history feature. Users can switch between versions using a dropdown (`handleVersionChange`), which fetches and displays the data for that specific version. Saving changes (`handleSaveChanges`) creates a new version. Restoring an old version (`handleRestoreVersion`) also creates a new version with the old data.
- Edit Mode: The component can be toggled into an `isEditMode` where content fields become editable text areas. A `hasUnsavedChanges` flag tracks unsaved edits.
- Test Execution Mode: If a `testRunId` is passed in props, the component displays an execution-focused UI. It shows the current result (`runStatus`) and provides buttons to quickly mark the test as passed, failed, etc. (`handleQuickStatus`, `handleMarkStatus`). Updating a status can trigger a dialog for adding defects.
- AI Healing Integration: Provides a "Heal with AI" feature that opens a dialog (`showHealDialog`) for the user to describe desired changes. `handleStartHealing` calls the `AIHealingService` and then navigates to the dedicated `HealTestCaseModule` with the results.
- Tabbed Section: An interactive tabs area manages Attachments (with upload functionality via `TestCaseAttachmentService`), Comments (with full CRUD), and Activity (a read-only log of all changes).
- Styling: A large, self-contained `<style>` block at the top of the component defines a custom, detailed "receipt paper" design for the main content area, along with styles for badges, dialogs, and other elements.
- Subcomponents: Contains several locally defined helper components like `StatusBadge`, `PriorityDot`, `SectionHeader`, `TabItem`, `EditableTextArea`, and `StatusOption` to modularize the complex UI.
Important interactions or dependencies with other files or modules:
- It has a high number of dependencies on backend services, including services for test cases, suites, milestones, projects, comments, activities, defects, attachments, AI settings, AI healing, and test run results.
- It uses many custom UI components from the `../ui` directory.
- It uses the `onNavigate` prop to switch to other modules like `HealTestCaseModule`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component's dual functionality (view vs. execution mode) is a key architectural feature, controlled by the presence of the `testRunId` prop.
- The use of an inline `<style>` tag for component-specific, complex styling is an unconventional choice but keeps all styling logic within the file.
- It dispatches a `StorageEvent` on `test_run_updated` after saving a test result. This is a clever way to enable real-time updates in other open browser tabs, such as the `TestRunDetailsModule`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/TestRunDetailsModule.tsx
Purpose or role in the project: This component provides a detailed dashboard for a single test run. It allows users to monitor the progress of a manual test execution, view the status of each test case, and manage the run itself.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestRunDetailsModule`: The main React functional component.
- `ExecutionStatus`: A type alias for the possible statuses of a test case within a run.
- State Management: Uses `useState` hooks to manage the test run data (`testRun`), associated test cases (`testCases`), execution results (`testResults`), execution state (`isRunning`, `isPaused`, `executionProgress`), UI state (`editMode`), and dialog state (`showAddCasesDialog`).
- Data Fetching: `loadTestRunData` fetches the run and its related entities on mount. `loadTestResults` fetches the status of all test cases in the run.
- Real-time Updates: A `useEffect` hook listens for `storage` events with the key `test_run_updated`. This allows the component to automatically refresh its data when another component (like `TestCaseDetailsModule`) updates a test result, enabling a live-dashboard experience. It also uses a custom `useSmartPolling` hook (though disabled by default) for periodic background refreshes.
- Data Synchronization: A `useEffect` hook is responsible for merging the list of `testCases` with the fetched `testResults` to create a unified `executions` array that drives the main table display.
- Execution Flow: The `startTestRun` function initiates a manual test run by navigating the user to the `TestCaseDetailsModule` for the first test case, passing along the `testRunId`. This puts the details view into its execution mode.
- UI Structure: The page includes a header with editable run details, a grid of cards for controls and statistics, and a main table listing all test cases. The table shows the status, duration, and result of each test and provides actions to view the case or remove it from the run.
- Test Case Management: Provides functionality to add (`handleOpenAddCases`, `handleAddSelectedCases`) or remove (`handleDeleteTestCase`) test cases from the run.
Important interactions or dependencies with other files or modules:
- Interacts with `TestRunService`, `TestCaseService`, `testSuiteService`, `milestoneService`, and `TestRunResultService` for data.
- Navigates to the `TestCaseDetailsModule` to perform the actual test execution for a single case.
- Listens for `StorageEvent`s dispatched by `TestCaseDetailsModule` to achieve real-time state synchronization.
- Uses the custom `useSmartPolling` hook.
- Uses custom UI components and `lucide-react` icons.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The use of `StorageEvent` for cross-component/cross-tab communication is a sophisticated technique for building a collaborative, real-time application without relying on WebSockets.
- The component clearly separates the run-level view from the case-level execution, delegating the latter to `TestCaseDetailsModule`.
- Includes mock/placeholder logic for an automated run (`executeTestCases`, `simulateTestExecution`), suggesting future feature expansion.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/TraineesModule.tsx
Purpose or role in the project: This component is part of a suite of modules seemingly related to a medical training application, rather than a software testing tool. It provides a directory for managing medical trainees, showing their personal information, course enrollment, and progress.
Main components, functions, classes, or constants with brief technical descriptions:
- `TraineesModule`: The main functional React component.
- Mock Data: The entire component is driven by hardcoded data arrays: `traineesData`, `courses`, and `branches`. It does not interact with any backend services.
- State Management: Uses `useState` to manage UI state, including the currently selected trainee for viewing in a dialog (`selectedTrainee`), the visibility of dialogs (`isProfileOpen`, `isAssignCourseOpen`), and filter values (`filterStatus`, `filterBranch`).
- `filteredTrainees`: A derived array that filters the mock `traineesData` based on the selected filter values.
- Helper Functions: `getStatusBadge` and `getProgressColor` are used for applying conditional styling within the trainee table.
- UI Structure: The layout includes a header with an "Add Trainee" button, a grid of statistics cards, a `Card` for filter controls, and a main `Table` displaying the trainee directory.
- Dialogs: It uses `Dialog` components for viewing a detailed trainee profile (`isProfileOpen`) and for a form to assign a course to a trainee (`isAssignCourseOpen`).
Important interactions or dependencies with other files or modules:
- It uses a variety of custom UI components from the `../ui` directory, such as `Card`, `Button`, `Table`, `Dialog`, `Select`, `Badge`, and `Progress`.
- Icons are from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component is a self-contained UI mockup that demonstrates how a trainee management system would look and feel.
- The thematic content (CNIC numbers, hospital branches, medical course names) strongly suggests this is either an unrelated example module or part of a different application context included in this codebase.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/TrainerDataModule.tsx
Purpose or role in the project: This component provides a data analytics dashboard for "trainers," continuing the medical training theme seen in other modules. It visualizes trainer-related data using various charts.
Main components, functions, classes, or constants with brief technical descriptions:
- `TrainerDataModule`: The main functional React component.
- Mock Data: All data visualized by the component is hardcoded in constant arrays, such as `trainerAgeDistributionData`, `treatmentStatusData`, `monthlyProgressData`, and `trainerPerformanceData`.
- Data Visualization: This is the core purpose of the component. It uses the `recharts` library to render several types of charts:
  - `BarChart`: For trainer age distribution.
  - `PieChart`: For the breakdown of training statuses.
  - `AreaChart`: To show monthly trends in new trainers, completions, and dropouts.
- UI Structure: The layout consists of a header, a grid of key metric cards, three chart cards, and a final card that lists top trainer performance in a table-like format.
Important interactions or dependencies with other files or modules:
- It uses custom UI components like `Card` and `Badge`.
- It depends on the `recharts` library for all its charting capabilities.
- Icons are from `lucide-react`.
- It has no dependencies on backend services.
Special configurations, assets, or third-party libraries if present: The key third-party library is `recharts`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component serves as a showcase for data visualization using `recharts` within the project's design system. It demonstrates how to integrate and configure different chart types.
- The content is specific to the medical training theme, aligning with `TraineesModule` and `ScheduleModule`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/TrainersModule.tsx
Purpose or role in the project: This module is for managing a directory of medical trainers. It provides a table view of trainers, their specialties, and performance metrics, along with dialogs for creating new trainers, viewing profiles, and assigning courses. It is part of the medical training suite of components.
Main components, functions, classes, or constants with brief technical descriptions:
- `TrainersModule`: The main functional React component.
- Mock Data: The component is built using hardcoded data arrays: `trainersData`, `specialties`, `branches`, and `courses`.
- State Management: Uses `useState` hooks to manage the currently selected trainer (`selectedTrainer`), the visibility of various dialogs (`isProfileOpen`, `isAssignCourseOpen`, `isAddTrainerOpen`), and the form data for a new trainer (`newTrainer`).
- Helper Functions: `getStatusBadge` and `getAvailabilityBadge` provide conditionally styled `Badge` components.
- UI Structure: The layout includes a header with an "Add Trainer" button, a grid of statistics cards, and a main `Table` of trainers. `Dialog` components are used for the "Add Trainer" form, a detailed trainer profile view, and a course assignment form.
Important interactions or dependencies with other files or modules:
- It uses custom UI components from the `../ui` directory, including `Card`, `Button`, `Table`, `Dialog`, `Select`, `Input`, `Label`, and `Badge`.
- Icons are from `lucide-react`.
- There are no dependencies on backend services.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This is another self-contained UI mockup using local, hardcoded data, consistent with the other medical training-themed modules. It provides a complete visual representation of a trainer management feature.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/UserManagement.jsx
Purpose or role in the project: This file contains a React component for comprehensive user management. It allows administrators to perform CRUD operations on user accounts, manage roles, and view user activity. It also provides functionality for the currently logged-in user to edit their own profile and change their password.
Main components, functions, classes, or constants with brief technical descriptions:
- `UserManagement`: The main functional component.
- State Management: Uses `useState` and `useEffect` to manage the list of `users`, the `currentUser` object, loading states, search/filter terms, and the visibility of various dialogs for user actions. Separate state objects (`newUser`, `editUser`, etc.) hold form data.
- Data Fetching: The `loadData` function, called on component mount, fetches both the complete user list and the current user's data using `UserService`.
- CRUD and Profile Handlers: Contains async functions (`handleCreateUser`, `handleEditUser`, `handleDeleteUser`, `handleUpdateProfile`, `handleChangePassword`) that call methods on the `UserService`. On success, they update the local component state to reflect the changes and show a toast notification.
- Helper Functions: Includes utilities like `getRoleBadgeColor`, `formatDate`, and `getInitials` for formatting data in the UI.
- UI Structure: The component renders a header with profile actions, statistics cards, a main `Card` containing filter controls and a user table, and multiple `Dialog` components for each action (create, edit, delete, profile update, password change).
Important interactions or dependencies with other files or modules:
- It heavily relies on the `UserService` to interact with the user management API endpoints.
- It uses `toast` from `sonner` for notifications.
- It uses a suite of custom UI components from `../ui`, including `Card`, `Button`, `Input`, `Dialog`, `Switch`, `Badge`, and `Select`.
- It uses icons from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component clearly separates administrative actions (managing all users) from personal actions (editing one's own profile), providing different entry points for each.
- It prevents a user from deleting their own account by disabling the delete button if the user's ID matches the current user's ID.
- This file is a `.jsx` file, indicating it may have been written without TypeScript, unlike most other components in the project which are `.tsx`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/modules/UserPermissionsModule.tsx
Purpose or role in the project: This component provides a UI for managing user accounts and viewing role-based permissions. It displays a list of users and a read-only view of the permissions associated with different roles.
Main components, functions, classes, or constants with brief technical descriptions:
- `UserPermissionsModule`: The main functional React component.
- Mock Data: The component is built entirely on hardcoded data. `userData` is an array of user objects, and `rolePermissions` is an object mapping roles to a set of boolean permissions.
- State Management: Uses `useState` to manage the `selectedRole` for the permissions viewer and the state for the "Create User" dialog (`isCreateUserOpen`, `newUser`).
- UI Structure: Features a two-column layout. The left column (`lg:col-span-2`) contains a table of users, with an "Add User" button that opens a creation dialog. The right column contains a `Card` where a user can select a role from a dropdown to see the associated permissions displayed as a series of disabled `Switch` components.
- Helper Functions: `getRoleBadgeColor` and `getStatusBadgeColor` provide conditional styling for badges.
Important interactions or dependencies with other files ormodules:
- Uses custom UI components from `../ui`, such as `Card`, `Button`, `Table`, `Dialog`, `Select`, `Switch`, and `Badge`.
- Icons are from `lucide-react`.
- It has no dependencies on backend services.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component appears to be a UI mockup or an earlier, simpler version of the user management functionality, as it uses mock data and its features are more fully realized in the `UserManagement.jsx` component. The permissions view is read-only, suggesting role permissions are managed elsewhere or are hardcoded in the backend.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/projects/AggregateVersionManager.tsx
Purpose or role in the project: This component is responsible for displaying and managing the version history of an AI-generated project's "aggregate response" data. It allows users to view past versions and restore a project's structure to a previous state.
Main components, functions, classes, or constants with brief technical descriptions:
- `AggregateVersionManager`: The main functional React component. It accepts `projectId`, `currentVersion`, and an `onVersionRestored` callback as props.
- State Management: Uses `useState` hooks to manage the list of `versions`, loading and error states, the `selectedVersion` for actions, dialog visibility, and the `previewData`.
- `loadVersions`: An async function that fetches the version history for the specified `projectId` from the backend API (`/api/v1/ai/projects/{projectId}/aggregate-versions`). It directly uses `fetch` and handles authentication by getting the token from `localStorage`.
- `handleRestoreConfirm`: An async function that makes a POST request to the restore endpoint. Upon success, it updates its own UI, reloads the version list, and calls the `onVersionRestored` callback to notify the parent component of the change.
- `getStatsSummary`: A utility function that parses the `aggregate_data` of a version to count entities like milestones and test cases for display in the UI.
- UI Structure: Renders a `Card` that lists all available versions. The latest version is highlighted. Each version entry displays metadata, a summary of its contents, and buttons for "Preview" and "Restore". A `Dialog` is used to confirm the restore action. A preview panel can be shown to display the raw JSON of a selected version.
Important interactions or dependencies with other files or modules:
- It interacts directly with the backend AI aggregate versions API using `fetch`.
- It communicates back to its parent component (e.g., `ProjectDetailsModule`) via the `onVersionRestored` callback to trigger a data refresh.
- It uses custom UI components like `Card`, `Button`, `Badge`, `Dialog`, and `Alert`.
- It uses `date-fns` for date formatting and `lucide-react` for icons.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component encapsulates the entire version management logic for AI-generated project structures, making it a reusable and focused piece of functionality.
- It provides a critical safety feature for the AI-healing process, allowing users to undo changes by restoring a previous aggregate state. The backend handles the actual restoration logic, while this component provides the user interface for it.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/test-cases/TestCaseModal.tsx
Purpose or role in the project: This file defines a reusable modal component for creating and editing test cases. It provides a comprehensive form for all test case attributes.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseModal`: The main functional React component, which operates in either "create" or "edit" mode based on whether a `testCase` prop is provided.
- State Management: Uses `useState` for `isLoading` status during submission, `projectMembers` for the assignee dropdown, and `formData` to hold the state of all form fields.
- `useEffect` hooks: One hook initializes or updates the form data when the `testCase` prop changes (for editing). Another hook fetches the list of project members via `projectService` when the modal is opened.
- `handleSubmit`: An async function that handles form submission. It validates the title and suite ID, then constructs the appropriate payload (`TestCaseCreate` or `TestCaseUpdate`) and calls the corresponding method on `TestCaseService`. It shows toasts, calls the success callbacks (`onTestCaseCreated` or `onTestCaseUpdated`), and closes the modal.
- Form Fields: The form includes inputs for title, preconditions, steps, expected results, and dropdowns (Select) for test suite, priority, type, milestone, and assignee.
Important interactions or dependencies with other files or modules:
- It is designed to be controlled by a parent component (like `ProjectDetailsModule`), which passes in props like `isOpen`, `onClose`, and the data to be edited.
- It depends on `TestCaseService` for creating/updating test cases and `projectService` for fetching project members.
- It uses constants `TEST_CASE_PRIORITIES` and `TEST_CASE_TYPES` from the `test-cases` service file for populating dropdowns.
- It uses `toast` from `sonner` for notifications.
- It uses various custom UI components (`Dialog`, `Button`, `Input`, `Label`, `Textarea`, `Select`).
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component is a classic example of a controlled form modal. It encapsulates all the logic for creating and editing a specific data entity.
- The test suite selection is disabled when editing an existing test case, enforcing a business rule that a test case cannot be moved between suites via this form.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/test-plans/TestPlanModal.tsx
Purpose or role in the project: This file contains a modal component for creating and editing test plans.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestPlanModal`: The main functional React component. It operates in "create" or "edit" mode depending on whether the `testPlan` prop is provided.
- State Management: Uses `useState` hooks to manage the form fields (`name`, `description`), a loading state (`isLoading`), and an error message state (`error`).
- `useEffect` hook: Populates the form fields with the data from the `testPlan` prop when it's provided for editing.
- `handleSubmit`: An asynchronous function that handles form submission. It validates that the name is not empty, then calls either `testPlanService.createTestPlan` or `testPlanService.updateTestPlan`. On success, it triggers a custom `toast` event, calls the `onTestPlanUpdated` callback, and closes the modal.
Important interactions or dependencies with other files or modules:
- It interacts with the `testPlanService` to perform CRUD operations on test plans.
- It is controlled by a parent component via props like `isOpen` and `onClose`.
- It uses custom UI components (`Dialog`, `Button`, `Input`, `Label`, `Textarea`) and `lucide-react` for the loader icon.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component uses a custom event `new CustomEvent('toast', ...)` to trigger toast notifications. This decouples it from a specific toast library implementation, though it requires a listener to be set up elsewhere in the application.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/test-runs/SimpleTestRunModal.tsx
Purpose or role in the project: This file provides a very basic modal for creating a new test run, asking only for a name. It is a simplified version of `TestRunModal`.
Main components, functions, classes, or constants with brief technical descriptions:
- `SimpleTestRunModal`: The main functional React component.
- State Management: A single `useState` hook for the `name` of the test run.
- `handleSubmit`: A function that is triggered on form submission. It checks if the name is not empty, constructs a default test run object with status 'draft' and type 'run', calls the `onSubmit` prop with this data, and then clears its state and closes.
Important interactions or dependencies with other files or modules:
- This is a presentational component that communicates with its parent via the `onSubmit` and `onClose` props.
- It uses basic UI components: `Dialog`, `Button`, and `Input`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component exemplifies a simplified user experience for a common action. It creates a test run with sensible defaults, allowing the user to provide more details later if needed.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/test-runs/TestRunModal.tsx
Purpose or role in the project: This component provides a comprehensive modal form for creating and editing test runs, offering more options than the `SimpleTestRunModal`.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestRunModal`: The main functional React component. It operates in either 'create' or 'edit' mode, determined by the `mode` prop.
- Local Constants: It defines `TEST_RUN_STATUSES` and `TEST_RUN_TYPES` locally, which are used to populate dropdowns.
- State Management: A single `formData` state object holds all the form fields (name, description, status, type, etc.).
- `useEffect` hook: This hook synchronizes the `formData` with the `testRun` prop when the modal is opened in 'edit' mode, or resets it for 'create' mode.
- `handleSubmit`: This function prepares the data for submission by cleaning up optional fields (e.g., converting empty strings to undefined) and converting the date to ISO format, then calls the `onSubmit` prop with the final data object.
- `handleInputChange`: A generic handler for updating fields in the `formData` state object.
Important interactions or dependencies with other files or modules:
- It is a controlled component, receiving its state and behavior via props (`isOpen`, `onClose`, `onSubmit`, `testRun`, etc.) from a parent component.
- It depends on types (`TestRunCreate`, `TestRunUpdate`) from the `test-runs` service.
- It uses a suite of custom UI components from the `../ui` directory.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The use of a single `formData` state object simplifies state management for the form.
- The component correctly handles optional fields in `handleSubmit` by deleting them from the payload if they are empty, ensuring clean data is sent to the API.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/test-suites/TestSuiteModal.tsx
Purpose or role in the project: This file contains a modal component for creating and editing test suites. Its structure and functionality are very similar to the `TestPlanModal`.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestSuiteModal`: The main functional React component, which can operate in "create" or "edit" mode.
- State Management: Uses `useState` for form fields (`name`, `description`), a loading state (`isLoading`), and an error message (`error`).
- `useEffect` hook: Populates the form fields from the `testSuite` prop when in edit mode.
- `handleSubmit`: An asynchronous function that validates the name and calls the appropriate method on `testSuiteService` (`createTestSuite` or `updateTestSuite`). It uses the custom `toast` event dispatching mechanism for notifications.
Important interactions or dependencies with other files or modules:
- It interacts with the `testSuiteService` for CRUD operations.
- It is controlled by a parent component via props.
- It uses custom UI components (`Dialog`, `Button`, `Input`, `Label`, `Textarea`) and the `Loader2` icon from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The component follows a standard, reusable pattern for a simple CRUD modal, which is consistent with `TestPlanModal`, promoting code uniformity.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/FileTree.tsx
Purpose or role in the project: This is a complex UI component designed to display a hierarchical file structure, similar to a file explorer in an IDE. It can show a nested tree view or a flat list of files, and includes a preview pane for viewing file contents.
Main components, functions, classes, or constants with brief technical descriptions:
- `FileTree`: The main component that wraps the entire functionality. It manages the view mode ('tree' or 'list'), filter state, and renders the layout.
- `FileNode`: A recursive component that renders a single file or directory in the tree. It handles indentation, icons, expansion/collapse of directories, and selection.
- `CodePreview`: A component that displays the content of a selected file. It includes a fallback to plain text if syntax highlighting fails and shows a truncation message if the file exceeds `maxPreviewLines`.
- State Management: `FileTree` uses `useState` to manage `expandedDirs` (a Set of paths for expanded directories), `viewMode`, and `filterLanguage`.
- Helper Functions:
  - `getFileIcon`: Returns an appropriate icon based on file type, extension, and whether a directory is expanded.
  - `formatFileSize`: Converts bytes into a human-readable string (KB, MB).
  - `handleExpandAll`/`handleCollapseAll`: Utility functions to control the tree view's expansion state.
Important interactions or dependencies with other files or modules:
- It receives a `parseResult` object from the `ZipParserService` as its primary data source.
- It communicates file selection back to its parent component via the `onFileSelect` callback prop.
- It uses several custom UI components like `Button`, `Card`, `Badge`, `Collapsible`, and `ScrollArea`.
- It uses icons from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The `FileNode` component uses recursion to render the nested tree structure, a classic pattern for hierarchical data.
- The use of a `Set` for `expandedDirs` provides an efficient way to manage the expansion state of many directories.
- The component is flexible, offering both a hierarchical 'tree' view and a flat 'list' view, which can be filtered by language. This caters to different user preferences for exploring codebases.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/Toast.tsx
Purpose or role in the project: This file provides a custom toast notification system for the application. It includes a provider component to render the toasts and a helper function to trigger them from anywhere in the app.
Main components, functions, classes, or constants with brief technical descriptions:
- `ToastProvider`: A React component that should be placed at the top level of the application. It listens for custom 'toast' events on the `window` object and manages the state of currently displayed toasts.
- `showToast`: A helper function that dispatches a `CustomEvent` named 'toast'. This is the imperative API used by other components to display a notification.
- `ToastData` interface: Defines the structure of the toast event's detail payload, requiring a `type` ('success', 'error', 'info') and a `message`.
Important interactions or dependencies with other files or modules:
- Other components in the application (e.g., `TestPlanModal`) can use the `showToast` function to display notifications without needing to import the `ToastProvider` or manage toast state themselves.
- The `App` component would typically render `ToastProvider` once to enable the system globally.
Notable implementation details, architectural patterns, or non-trivial techniques:
- This component uses a global event bus pattern (`window.addEventListener` and `window.dispatchEvent`) to decouple the toast-triggering logic from the rendering logic. This allows any component, service, or function in the application to easily show a toast.
- Toasts are automatically removed after a 5-second timeout, which is managed within the `ToastProvider` component.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/accordion.tsx
Purpose or role in the project: This file provides a styled Accordion component for the application's design system.
Main components, functions, classes, or constants with brief technical descriptions:
- It exports four components: `Accordion`, `AccordionItem`, `AccordionTrigger`, and `AccordionContent`.
- These components are wrappers around the primitives provided by `@radix-ui/react-accordion`.
- `Accordion`: The root container for the accordion set.
- `AccordionItem`: A container for a single collapsible item.
- `AccordionTrigger`: The clickable header that toggles the content's visibility. It includes a `ChevronDownIcon` that rotates 180 degrees when the item is open.
- `AccordionContent`: The container for the content that is shown or hidden. It uses `animate-accordion-up` and `animate-accordion-down` classes (presumably defined in `tailwind.config.js`) for animations.
Important interactions or dependencies with other files or modules:
- It relies on `@radix-ui/react-accordion` for the core functionality and accessibility.
- It uses `lucide-react` for the chevron icon.
- It uses the `cn` utility from `./utils` to merge Tailwind CSS classes.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-accordion@1.2.3`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/alert-dialog.tsx
Purpose or role in the project: This file defines a styled Alert Dialog component, typically used for confirmation prompts that require user action before continuing.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports `AlertDialog`, `AlertDialogTrigger`, `AlertDialogPortal`, `AlertDialogOverlay`, `AlertDialogContent`, `AlertDialogHeader`, `AlertDialogFooter`, `AlertDialogTitle`, `AlertDialogDescription`, `AlertDialogAction`, and `AlertDialogCancel`.
- These are styled wrappers around the primitives from `@radix-ui/react-alert-dialog`.
- `AlertDialogContent`: Renders the dialog within a `Portal` on top of an `Overlay`. It includes animations for opening and closing.
- `AlertDialogAction`: The button for the confirm action.
- `AlertDialogCancel`: The button for the cancel action.
Important interactions or dependencies with other files or modules:
- It relies on `@radix-ui/react-alert-dialog` for functionality and accessibility.
- It uses the `cn` utility from `./utils` and `buttonVariants` from `./button` for consistent styling.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-alert-dialog@1.1.6`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/alert.tsx
Purpose or role in the project: This file defines a styled Alert component used for displaying important messages to the user.
Main components, functions, classes, or constants with brief technical descriptions:
- `alertVariants`: A `cva` (class-variance-authority) object that defines different styles for the alert, specifically a `default` and `destructive` variant.
- `Alert`: The main container component for the alert message.
- `AlertTitle`: A component for the alert's title.
- `AlertDescription`: A component for the alert's main body content.
Important interactions or dependencies with other files or modules:
- It uses `class-variance-authority` to manage different visual variants.
- It uses the `cn` utility from `./utils` for class name merging.
Special configurations, assets, or third-party libraries if present: `class-variance-authority@0.7.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/aspect-ratio.tsx
Purpose or role in the project: Provides a component to maintain the aspect ratio of a child element.
Main components, functions, classes, or constants with brief technical descriptions:
- `AspectRatio`: A simple wrapper component around `@radix-ui/react-aspect-ratio`'s `Root` component.
Important interactions or dependencies with other files or modules:
- It depends entirely on `@radix-ui/react-aspect-ratio`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-aspect-ratio@1.1.2`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/avatar.tsx
Purpose or role in the project: Defines a set of components for displaying user avatars.
Main components, functions, classes, or constants with brief technical descriptions:
- `Avatar`: The main container for an avatar.
- `AvatarImage`: The component to render the actual image. It should be used within `Avatar`.
- `AvatarFallback`: A placeholder that is displayed while the image is loading or if the image fails to load. It's typically used to show user initials.
- All components are styled wrappers around primitives from `@radix-ui/react-avatar`.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-avatar` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-avatar@1.1.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/badge.tsx
Purpose or role in the project: Defines a styled Badge component for displaying short, supplemental information, such as tags or statuses.
Main components, functions, classes, or constants with brief technical descriptions:
- `badgeVariants`: A `cva` object defining different visual styles: `default`, `secondary`, `destructive`, and `outline`.
- `Badge`: The main component that renders a `<span>` or a child component with the appropriate badge styles applied. It accepts a `variant` prop to select the style.
Important interactions or dependencies with other files or modules:
- It uses `class-variance-authority` to manage its variants.
- It uses `@radix-ui/react-slot` to allow the badge styles to be applied to a child component (via the `asChild` prop).
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-slot@1.1.2`, `class-variance-authority@0.7.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/breadcrumb.tsx
Purpose or role in the project: Provides a set of components for creating breadcrumb navigation trails.
Main components, functions, classes, or constants with brief technical descriptions:
- `Breadcrumb`: The root `<nav>` element.
- `BreadcrumbList`: An ordered list (`<ol>`) to contain the breadcrumb items.
- `BreadcrumbItem`: A list item (`<li>`) for each element in the trail.
- `BreadcrumbLink`: An anchor tag (`<a>`) for clickable links in the trail.
- `BreadcrumbPage`: A `<span>` for the current, non-clickable page in the trail.
- `BreadcrumbSeparator`: A list item (`<li>`) that renders a separator, defaulting to a `ChevronRight` icon.
- `BreadcrumbEllipsis`: A component to indicate that some breadcrumb items are hidden, rendering a `MoreHorizontal` icon.
Important interactions or dependencies with other files or modules:
- It uses `@radix-ui/react-slot` to allow `BreadcrumbLink` to wrap other components.
- It uses `lucide-react` for icons.
- It uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-slot@1.1.2`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/button.tsx
Purpose or role in the project: Defines a highly versatile and styled Button component.
Main components, functions, classes, or constants with brief technical descriptions:
- `buttonVariants`: A `cva` object defining numerous variants for the button's appearance (`default`, `destructive`, `outline`, `secondary`, `ghost`, `link`) and size (`default`, `sm`, `lg`, `icon`).
- `Button`: The main component that renders a `<button>` (or a child component if `asChild` is true) with the appropriate styles applied based on `variant` and `size` props. It uses `React.forwardRef` to correctly pass refs.
Important interactions or dependencies with other files or modules:
- It uses `class-variance-authority` for managing its complex set of variants.
- It uses `@radix-ui/react-slot` for compositional flexibility with the `asChild` prop.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-slot@1.1.2`, `class-variance-authority@0.7.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/calendar.tsx
Purpose or role in the project: Provides a styled Calendar component for date selection.
Main components, functions, classes, or constants with brief technical descriptions:
- `Calendar`: A React component that wraps the `DayPicker` component from the `react-day-picker` library. It provides extensive default styling via the `classNames` prop to match the application's design system. It also replaces the default navigation icons with `ChevronLeft` and `ChevronRight` from `lucide-react`.
Important interactions or dependencies with other files or modules:
- It is a wrapper around the `react-day-picker` library.
- It uses `lucide-react` for icons and `buttonVariants` from `./button` for styling navigation buttons.
- It uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `lucide-react@0.487.0`, `react-day-picker@8.10.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/card.tsx
Purpose or role in the project: Defines a set of components for building card-based UI layouts.
Main components, functions, classes, or constants with brief technical descriptions:
- `Card`: The main container with border and rounded corners.
- `CardHeader`: The top section of the card, designed to hold the title and description.
- `CardTitle`: The title element within the header.
- `CardDescription`: The description element within the header.
- `CardAction`: A container for actions (like buttons or menus) placed in the header.
- `CardContent`: The main body of the card.
- `CardFooter`: The bottom section of the card.
- These components are simple styled `div`s that use Flexbox and Grid to achieve a consistent layout.
Important interactions or dependencies with other files or modules:
- Uses the `cn` utility from `./utils` for styling.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/carousel.tsx
Purpose or role in the project: Provides a set of components for creating a carousel or slider.
Main components, functions, classes, or constants with brief technical descriptions:
- `Carousel`: The main provider component that sets up the carousel context and state using the `useEmblaCarousel` hook.
- `CarouselContent`: The scrollable container for the carousel items.
- `CarouselItem`: A wrapper for each individual slide in the carousel.
- `CarouselPrevious` and `CarouselNext`: Button components for navigating between slides. They automatically handle disabled states based on the carousel's position.
- `useCarousel`: A custom hook to access the carousel's context and API from within child components.
Important interactions or dependencies with other files or modules:
- It is built on top of the `embla-carousel-react` library.
- It uses `lucide-react` for navigation icons and the `Button` component from `./button`.
- It uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `embla-carousel-react@8.6.0`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/chart.tsx
Purpose or role in the project: This file provides a set of wrapper components for the `recharts` library, integrating it with the application's theming and design system.
Main components, functions, classes, or constants with brief technical descriptions:
- `ChartConfig`: A TypeScript type for defining the configuration of a chart, including labels, icons, and colors for different data series.
- `ChartContainer`: The main wrapper component that provides a `ChartContext` with the configuration. It uses `RechartsPrimitive.ResponsiveContainer` to make charts responsive.
- `ChartStyle`: A component that dynamically generates a `<style>` tag to inject CSS variables for the chart's colors based on the provided configuration and theme (light/dark).
- `ChartTooltip`, `ChartTooltipContent`: Wrappers for the Recharts Tooltip, with `ChartTooltipContent` being a highly customized component for rendering the tooltip's content in a style consistent with the design system.
- `ChartLegend`, `ChartLegendContent`: Wrappers for the Recharts Legend, with `ChartLegendContent` providing a custom rendering implementation.
- `useChart`: A custom hook to access the `ChartContext`.
Important interactions or dependencies with other files or modules:
- It is a comprehensive wrapper around the `recharts` library.
- It uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `recharts@2.15.2`.
Notable implementation details, architectural patterns, or non-trivial techniques: The `ChartStyle` component's method of generating CSS variables in a style tag is a clever way to bridge the gap between a CSS-variable-based design system and a charting library that often relies on props for color.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/checkbox.tsx
Purpose or role in the project: Provides a styled Checkbox component.
Main components, functions, classes, or constants with brief technical descriptions:
- `Checkbox`: A wrapper around `CheckboxPrimitive.Root` from `@radix-ui/react-checkbox`. It contains a `CheckboxPrimitive.Indicator` which renders a `CheckIcon` when the checkbox is checked. The component is styled to match the application's design system.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-checkbox` for functionality.
- Uses `lucide-react` for the check icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-checkbox@1.1.4`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/collapsible.tsx
Purpose or role in the project: Provides components for creating collapsible sections of content.
Main components, functions, classes, or constants with brief technical descriptions:
- `Collapsible`, `CollapsibleTrigger`, `CollapsibleContent`: These are simple, unstyled wrappers around the corresponding components from `@radix-ui/react-collapsible`. They provide the basic building blocks for creating collapsible UI elements.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-collapsible` for all functionality.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-collapsible@1.1.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/command.tsx
Purpose or role in the project: Provides a set of components for building command palettes (like VS Code's Ctrl+P).
Main components, functions, classes, or constants with brief technical descriptions:
- `Command`: The main wrapper from the `cmdk` library.
- `CommandDialog`: A component that wraps the `Command` component inside a `Dialog`, providing a ready-to-use command palette modal.
- `CommandInput`: The search input field.
- `CommandList`: The scrollable list of results.
- `CommandEmpty`: A component to display when there are no search results.
- `CommandGroup`: A component to group related items.
- `CommandItem`: A single selectable item in the list.
- `CommandSeparator`: A visual separator between groups or items.
- `CommandShortcut`: A component to display keyboard shortcuts on the right side of an item.
Important interactions or dependencies with other files or modules:
- Built on top of the `cmdk` library.
- `CommandDialog` uses the `Dialog` component from `./dialog`.
- Uses `lucide-react` for the search icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `cmdk@1.1.1`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/context-menu.tsx
Purpose or role in the project: Provides a full set of components for creating right-click context menus.
Main components, functions, classes, or constants with brief technical descriptions:
- This file exports a comprehensive set of styled wrappers for every component primitive available in `@radix-ui/react-context-menu`.
- Components include `ContextMenu`, `ContextMenuTrigger`, `ContextMenuContent`, `ContextMenuItem`, `ContextMenuCheckboxItem`, `ContextMenuRadioGroup`, `ContextMenuRadioItem`, `ContextMenuLabel`, `ContextMenuSeparator`, `ContextMenuShortcut`, and components for sub-menus (`ContextMenuSub`, `ContextMenuSubTrigger`, `ContextMenuSubContent`).
- The components are styled to match the application's design system and include animations for opening/closing.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-context-menu` for all functionality.
- Uses `lucide-react` for icons (check, chevron, circle).
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-context-menu@2.2.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/dialog.tsx
Purpose or role in the project: Provides a set of components for creating modal dialogs.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports `Dialog`, `DialogTrigger`, `DialogPortal`, `DialogClose`, `DialogOverlay`, `DialogContent`, `DialogHeader`, `DialogFooter`, `DialogTitle`, and `DialogDescription`.
- These are styled wrappers around `@radix-ui/react-dialog` primitives.
- `DialogContent`: The main dialog window, which includes a close button (`XIcon`) by default. It's rendered inside a `DialogPortal` to ensure it appears on top of other content.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-dialog` for functionality.
- Uses `lucide-react` for the close icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-dialog@1.1.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/drawer.tsx
Purpose or role in the project: Provides components for creating a drawer or bottom sheet, which is a common UI pattern on mobile devices.
Main components, functions, classes, or constants with brief technical descriptions:
- The file exports a set of components (`Drawer`, `DrawerTrigger`, `DrawerPortal`, `DrawerClose`, `DrawerOverlay`, `DrawerContent`, `DrawerHeader`, `DrawerFooter`, `DrawerTitle`, `DrawerDescription`) that wrap the `vaul` library.
- `DrawerContent`: The main component that slides into view. It includes styles for different `side`s (top, bottom, left, right) and a grab handle for bottom sheets.
Important interactions or dependencies with other files or modules:
- It is a wrapper around the `vaul` library.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `vaul@1.1.2`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/dropdown-menu.tsx
Purpose or role in the project: Provides a full set of components for creating dropdown menus.
Main components, functions, classes, or constants with brief technical descriptions:
- Similar to `context-menu.tsx`, this file exports a comprehensive set of styled wrappers for `@radix-ui/react-dropdown-menu` primitives.
- Components include `DropdownMenu`, `DropdownMenuTrigger`, `DropdownMenuContent`, `DropdownMenuItem`, `DropdownMenuCheckboxItem`, `DropdownMenuRadioGroup`, `DropdownMenuRadioItem`, `DropdownMenuLabel`, `DropdownMenuSeparator`, `DropdownMenuShortcut`, and sub-menu components.
- The components are styled consistently with the application's design system.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-dropdown-menu` for functionality.
- Uses `lucide-react` for icons.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-dropdown-menu@2.1.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/form.tsx
Purpose or role in the project: This file provides a set of components to facilitate building accessible and manageable forms using the `react-hook-form` library.
Main components, functions, classes, or constants with brief technical descriptions:
- `Form`: A wrapper for `FormProvider` from `react-hook-form`.
- `FormField`: A wrapper for the `Controller` component from `react-hook-form`, which integrates controlled components into the form. It also provides a `FormFieldContext`.
- `useFormField`: A custom hook that provides access to the field's state (e.g., `error`), name, and generated IDs for ARIA attributes.
- `FormItem`: A wrapper `div` that provides a context with a unique ID for its children.
- `FormLabel`: A styled `Label` component that is automatically connected to the form control via `htmlFor` and changes color when there is an error.
- `FormControl`: A wrapper that uses `Slot` to pass down necessary props (`id`, `aria-describedby`, `aria-invalid`) to the actual input component.
- `FormDescription`: A component for displaying help text associated with a form field.
- `FormMessage`: A component that conditionally renders the validation error message for a field.
Important interactions or dependencies with other files or modules:
- It is tightly integrated with `react-hook-form`.
- It uses `@radix-ui/react-label` and `@radix-ui/react-slot` for its underlying structure.
- It uses the custom `Label` component from `./label` and the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `react-hook-form@7.55.0`, `@radix-ui/react-label@2.1.2`, `@radix-ui/react-slot@1.1.2`.
Notable implementation details, architectural patterns, or non-trivial techniques: This file implements the "Provider" and "Compound Component" patterns to create a declarative and accessible API for form building. The `useFormField` hook is central to this, automatically wiring up ARIA attributes and state between the different form components.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/hover-card.tsx
Purpose or role in the project: Defines components for creating a pop-up card that appears when a user hovers over a trigger element.
Main components, functions, classes, or constants with brief technical descriptions:
- `HoverCard`, `HoverCardTrigger`, `HoverCardContent`: Styled wrappers for the corresponding primitives from `@radix-ui/react-hover-card`.
- `HoverCardContent`: The pop-up content that appears on hover. It is rendered in a `Portal` and includes animations.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-hover-card` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-hover-card@1.1.6`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/input-otp.tsx
Purpose or role in the project: Provides a set of components for building One-Time Password (OTP) or code input fields.
Main components, functions, classes, or constants with brief technical descriptions:
- `InputOTP`: The main component wrapper from the `input-otp` library.
- `InputOTPGroup`: A container for a group of input slots.
- `InputOTPSlot`: Represents a single character input slot. It includes logic to show the character and a fake caret when active.
- `InputOTPSeparator`: A component to render a separator (like a dash) between groups of slots.
Important interactions or dependencies with other files or modules:
- It is built on top of the `input-otp` library.
- Uses `lucide-react` for the `MinusIcon` separator.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `input-otp@1.4.2`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/input.tsx
Purpose or role in the project: Defines a styled text Input component.
Main components, functions, classes, or constants with brief technical descriptions:
- `Input`: A functional component that renders a standard HTML `<input>` element with a consistent set of styles applied via the `cn` utility. The styles include states for focus, disabled, and invalid (`aria-invalid`).
Important interactions or dependencies with other files or modules:
- Uses the `cn` utility from `./utils`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/json-viewer.tsx
Purpose or role in the project: This is a custom component designed to render JSON data in a user-friendly, collapsible tree format with syntax highlighting and a copy-to-clipboard feature.
Main components, functions, classes, or constants with brief technical descriptions:
- `JsonViewer`: The main component that wraps the JSON tree and provides the "Copy" button. It sets up the main container with a max height and scrollbars.
- `JsonNode`: A recursive component that renders a single node (key-value pair, array item, or object) in the JSON tree. It handles rendering different data types (string, number, boolean, null, object, array) with distinct colors. For objects and arrays, it manages its own expansion state (`isExpanded`) and renders its children by recursively calling itself.
- `handleCopy`: A function in `JsonViewer` that uses the `navigator.clipboard` API to copy the stringified JSON data.
Important interactions or dependencies with other files or modules:
- It uses the custom `Button` component from `./button` and icons from `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The recursive nature of the `JsonNode` component is the core architectural pattern, allowing it to render arbitrarily nested JSON structures.
- The component implements its own syntax highlighting by applying specific text colors to different data types, mimicking the appearance of a code editor.
- State for expansion is managed locally within each `JsonNode`, making the component self-contained.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/label.tsx
Purpose or role in the project: Defines a styled Label component for form inputs.
Main components, functions, classes, or constants with brief technical descriptions:
- `Label`: A wrapper around `LabelPrimitive.Root` from `@radix-ui/react-label`. It applies consistent styling and is designed to work with form elements, including styles for disabled states.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-label` for its base functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-label@2.1.2`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/menubar.tsx
Purpose or role in the project: Provides a set of components for creating a horizontal menu bar, similar to those found in desktop applications.
Main components, functions, classes, or constants with brief technical descriptions:
- This file exports a comprehensive set of styled wrappers for the primitives from `@radix-ui/react-menubar`.
- Components include `Menubar`, `MenubarMenu` (which contains a trigger and content), `MenubarTrigger`, `MenubarContent`, `MenubarItem`, `MenubarSeparator`, `MenubarCheckboxItem`, etc.
- The components are styled to create a familiar menu bar experience.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-menubar` for functionality.
- Uses `lucide-react` for icons.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-menubar@1.1.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/navigation-menu.tsx
Purpose or role in the project: Provides components for building a navigation menu, often used in application headers for top-level navigation, with support for dropdowns and complex layouts.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports styled wrappers for `@radix-ui/react-navigation-menu` primitives, including `NavigationMenu`, `NavigationMenuList`, `NavigationMenuItem`, `NavigationMenuTrigger` (which automatically adds a chevron icon), `NavigationMenuContent`, `NavigationMenuLink`, `NavigationMenuViewport`, and `NavigationMenuIndicator`.
- `NavigationMenuViewport`: The area where dropdown content is displayed. The component can operate with or without this shared viewport.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-navigation-menu` for functionality.
- Uses `class-variance-authority` for the trigger style.
- Uses `lucide-react` for the chevron icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-navigation-menu@1.2.5`, `class-variance-authority@0.7.1`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/pagination.tsx
Purpose or role in the project: Provides a set of components for rendering pagination controls.
Main components, functions, classes, or constants with brief technical descriptions:
- `Pagination`: The root `<nav>` container.
- `PaginationContent`: A `<ul>` container for the pagination items.
- `PaginationItem`: An `<li>` wrapper for each link or ellipsis.
- `PaginationLink`: A styled `<a>` tag for page numbers. It has an `isActive` prop for styling the current page.
- `PaginationPrevious` and `PaginationNext`: Specialized `PaginationLink` components that include "Previous"/"Next" text and chevron icons.
- `PaginationEllipsis`: A component to represent omitted pages, displaying a "more" icon.
Important interactions or dependencies with other files or modules:
- Uses `lucide-react` for icons.
- Uses `buttonVariants` from `./button` to style the links like buttons.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/popover.tsx
Purpose or role in the project: Defines components for creating a popover, a floating content element that appears when a trigger is clicked.
Main components, functions, classes, or constants with brief technical descriptions:
- `Popover`, `PopoverTrigger`, `PopoverContent`, `PopoverAnchor`: Styled wrappers for the corresponding primitives from `@radix-ui/react-popover`.
- `PopoverContent`: The main content area of the popover, rendered within a `Portal` and styled with animations.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-popover` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-popover@1.1.6`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/progress.tsx
Purpose or role in the project: Provides a styled Progress bar component.
Main components, functions, classes, or constants with brief technical descriptions:
- `Progress`: A wrapper around `ProgressPrimitive.Root` from `@radix-ui/react-progress`. It contains a `ProgressPrimitive.Indicator` whose width is controlled by an inline style based on the `value` prop.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-progress` for functionality.
- Uses the `cn` utility from `./utils`.
Notable implementation details, architectural patterns, or non-trivial techniques: The progress is set using `transform: translateX(-${100 - (value || 0)}%)` on the indicator, which is a common and performant way to animate progress bars.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-progress@1.1.2`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/radio-group.tsx
Purpose or role in the project: Provides components for creating a radio button group.
Main components, functions, classes, or constants with brief technical descriptions:
- `RadioGroup`: The wrapper for the group, from `@radix-ui/react-radio-group`.
- `RadioGroupItem`: A single radio button. It contains a `RadioGroupPrimitive.Indicator` which renders a `CircleIcon` to show the selected state.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-radio-group` for functionality.
- Uses `lucide-react` for the selected state icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-radio-group@1.2.3`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/resizable.tsx
Purpose or role in the project: Provides components for creating resizable panel layouts.
Main components, functions, classes, or constants with brief technical descriptions:
- `ResizablePanelGroup`: The container for a set of resizable panels, from `react-resizable-panels`.
- `ResizablePanel`: A single panel within the group.
- `ResizableHandle`: The divider between panels that the user can drag. It has a `withHandle` prop to optionally render a visible grip icon.
Important interactions or dependencies with other files or modules:
- It is a set of styled wrappers for the `react-resizable-panels` library.
- Uses `lucide-react` for the grip icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `react-resizable-panels@2.1.7`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/scroll-area.tsx
Purpose or role in the project: Provides a cross-browser scrollable area with a styled scrollbar.
Main components, functions, classes, or constants with brief technical descriptions:
- `ScrollArea`: The main wrapper component from `@radix-ui/react-scroll-area`. It contains a `Viewport` and a `ScrollBar`.
- `ScrollBar`: The styled scrollbar component, which can be vertical or horizontal. It contains a `ScrollAreaThumb` which is the draggable part.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-scroll-area` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-scroll-area@1.2.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/select.tsx
Purpose or role in the project: Provides a highly customizable and accessible Select (dropdown) component.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports a comprehensive set of styled wrappers for `@radix-ui/react-select` primitives.
- Components include `Select`, `SelectGroup`, `SelectValue`, `SelectTrigger` (which automatically adds a chevron), `SelectContent`, `SelectLabel`, `SelectItem`, `SelectSeparator`, and scroll buttons.
- `SelectContent`: The dropdown list, which is rendered in a `Portal`.
- `SelectItem`: A single option in the list, which includes a checkmark indicator for the selected item.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-select` for functionality.
- Uses `lucide-react` for icons.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-select@2.1.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/separator.tsx
Purpose or role in the project: Provides a simple component to render a horizontal or vertical dividing line.
Main components, functions, classes, or constants with brief technical descriptions:
- `Separator`: A wrapper around `SeparatorPrimitive.Root` from `@radix-ui/react-separator`. It takes an `orientation` prop ('horizontal' or 'vertical') to control its direction.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-separator`.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-separator@1.1.2`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/sheet.tsx
Purpose or role in the project: Provides components for creating a "sheet" or slide-over panel that appears from the side, top, or bottom of the screen.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports styled wrappers for `@radix-ui/react-dialog` primitives, repurposed for a sheet-like appearance.
- Components include `Sheet`, `SheetTrigger`, `SheetClose`, `SheetPortal`, `SheetOverlay`, `SheetContent`, `SheetHeader`, `SheetFooter`, `SheetTitle`, `SheetDescription`.
- `SheetContent`: The main panel that slides in. Its styles and animations change based on the `side` prop ('top', 'right', 'bottom', 'left').
Important interactions or dependencies with other files or modules:
- It is built on top of `@radix-ui/react-dialog`, demonstrating how Radix primitives can be adapted for different UI patterns.
- Uses `lucide-react` for the close icon.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-dialog@1.1.6`, `lucide-react@0.487.0`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/sidebar.tsx
Purpose or role in the project: This is a highly complex and reusable sidebar component system. It supports multiple variants (standard, floating, inset), collapsible states (icon-only, off-canvas), mobile responsiveness, and a rich set of sub-components for building out sidebar navigation.
Main components, functions, classes, or constants with brief technical descriptions:
- `SidebarProvider`: The main context provider that manages the sidebar's state (open/collapsed, mobile vs. desktop). It also handles state persistence using cookies and sets up a keyboard shortcut.
- `useSidebar`: A hook to access the sidebar's context.
- `Sidebar`: The main component that renders either a mobile `Sheet` or a desktop sidebar based on screen size. It handles the complex styling and layout for different variants and states.
- `SidebarTrigger`: A button to toggle the sidebar's visibility.
- `SidebarInset`: A `<main>` component designed to be used with the "inset" variant, which correctly positions itself next to the sidebar.
- Sub-components: A large number of sub-components are provided for building the sidebar's content, including `SidebarHeader`, `SidebarContent`, `SidebarFooter`, `SidebarGroup` (with labels and actions), and `SidebarMenu` (with items, buttons, actions, badges, and sub-menus). `SidebarMenuButton` is particularly notable as it integrates with `Tooltip` to show item names when the sidebar is collapsed to icon-only mode.
Important interactions or dependencies with other files or modules:
- It uses the custom `useIsMobile` hook.
- It uses several other UI components from the same directory, including `Sheet`, `Button`, `Input`, `Separator`, `Tooltip`, and `Skeleton`.
- It depends on `@radix-ui/react-slot`.
Special configurations, assets, or third-party libraries if present: `lucide-react`.
Notable implementation details, architectural patterns, or non-trivial techniques: This is a very advanced implementation of a sidebar, using a combination of React Context, a custom hook, CSS variables, and extensive data attributes (`data-state`, `data-variant`, etc.) with Tailwind CSS for highly flexible and themeable styling. The automatic handling of mobile vs. desktop views and the persistence of the collapsed/expanded state in a cookie are key features.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/skeleton.tsx
Purpose or role in the project: Provides a simple Skeleton component used as a placeholder while content is loading.
Main components, functions, classes, or constants with brief technical descriptions:
- `Skeleton`: A functional component that renders a `div` with a pulsing animation (`animate-pulse`) and a background color to mimic a loading state.
Important interactions or dependencies with other files or modules:
- Uses the `cn` utility from `./utils`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/slider.tsx
Purpose or role in the project: Provides a styled Slider component for selecting a value or range of values.
Main components, functions, classes, or constants with brief technical descriptions:
- `Slider`: A wrapper around `SliderPrimitive.Root` from `@radix-ui/react-slider`. It includes a `Track`, a `Range` (the filled part of the track), and one or more `Thumb`s (the draggable handles). It supports both single-value sliders and range sliders.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-slider` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-slider@1.2.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/sonner.tsx
Purpose or role in the project: A wrapper component for the `sonner` toast notification library, integrating it with the application's theming.
Main components, functions, classes, or constants with brief technical descriptions:
- `Toaster`: A client component that wraps the `Toaster` from `sonner`. It uses the `useTheme` hook from `next-themes` to automatically set the toast's theme (light/dark) to match the application's theme. It also sets custom CSS variables to style the toasts according to the design system.
Important interactions or dependencies with other files or modules:
- It is a wrapper for the `sonner` library.
- It depends on `next-themes` to get the current theme.
Special configurations, assets, or third-party libraries if present: `next-themes@0.4.6`, `sonner@2.0.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/switch.tsx
Purpose or role in the project: Provides a styled Switch or toggle component.
Main components, functions, classes, or constants with brief technical descriptions:
- `Switch`: A wrapper around `SwitchPrimitive.Root` from `@radix-ui/react-switch`. It contains a `SwitchPrimitive.Thumb` that animates its position based on the checked state. The component is styled to match the design system for both on and off states.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-switch` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-switch@1.1.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/table.tsx
Purpose or role in the project: Provides a set of styled components for creating data tables.
Main components, functions, classes, or constants with brief technical descriptions:
- Exports components for all standard table elements: `Table`, `TableHeader`, `TableBody`, `TableFooter`, `TableRow`, `TableHead`, `TableCell`, and `TableCaption`.
- These are simple functional components that render the corresponding HTML table elements (`<table>`, `<thead>`, etc.) with consistent Tailwind CSS classes applied via the `cn` utility.
- `Table`: The main `<table>` element is wrapped in a `div` with `overflow-x-auto` to make tables horizontally scrollable on small screens.
Important interactions or dependencies with other files or modules:
- Uses the `cn` utility from `./utils`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/tabs.tsx
Purpose or role in the project: Provides components for creating tabbed interfaces.
Main components, functions, classes, or constants with brief technical descriptions:
- `Tabs`, `TabsList`, `TabsTrigger`, `TabsContent`: Styled wrappers for the corresponding primitives from `@radix-ui/react-tabs`.
- `TabsTrigger`: The clickable tab button. It has specific styles for the active state (`data-[state=active]`).
- `TabsList`: The container for the triggers.
- `TabsContent`: The container for the content of a single tab.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-tabs` for functionality.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-tabs@1.1.3`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/textarea.tsx
Purpose or role in the project: Defines a styled Textarea component.
Main components, functions, classes, or constants with brief technical descriptions:
- `Textarea`: A functional component that renders a standard HTML `<textarea>` element with consistent styles from the design system. The class `field-sizing-content` suggests it may be styled to automatically grow with its content.
Important interactions or dependencies with other files or modules:
- Uses the `cn` utility from `./utils`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/toggle-group.tsx
Purpose or role in the project: Provides components for creating a group of toggle buttons, where one or more can be selected at a time.
Main components, functions, classes, or constants with brief technical descriptions:
- `ToggleGroup`: The main wrapper for the group, from `@radix-ui/react-toggle-group`. It provides a `ToggleGroupContext` to pass down variant and size props to its children.
- `ToggleGroupItem`: A single toggle button within the group. It consumes the context to get its styles, ensuring all items in a group look consistent.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-toggle-group`.
- Uses `toggleVariants` from `./toggle` to share styling with the standalone `Toggle` component.
- Uses `class-variance-authority` for variant management.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-toggle-group@1.1.2`, `class-variance-authority@0.7.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/toggle.tsx
Purpose or role in the project: Defines a styled Toggle button component that can be pressed on or off.
Main components, functions, classes, or constants with brief technical descriptions:
- `toggleVariants`: A `cva` object that defines styles for variants (`default`, `outline`) and sizes (`default`, `sm`, `lg`).
- `Toggle`: A wrapper around `TogglePrimitive.Root` from `@radix-ui/react-toggle`. It applies the styles defined in `toggleVariants`.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-toggle`.
- The `toggleVariants` are also used by `toggle-group.tsx`.
- Uses `class-variance-authority` and the `cn` utility.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-toggle@1.1.2`, `class-variance-authority@0.7.1`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/tooltip.tsx
Purpose or role in the project: Provides components for creating tooltips that appear when hovering over an element.
Main components, functions, classes, or constants with brief technical descriptions:
- `TooltipProvider`: A provider from `@radix-ui/react-tooltip` that can be used to configure tooltips globally (e.g., `delayDuration`).
- `Tooltip`: A convenient wrapper that includes a `TooltipProvider`.
- `TooltipTrigger`: The element that the user hovers over.
- `TooltipContent`: The content that appears in the tooltip. It includes a `TooltipPrimitive.Arrow` to render a small pointer.
Important interactions or dependencies with other files or modules:
- Depends on `@radix-ui/react-tooltip`.
- Uses the `cn` utility from `./utils`.
Special configurations, assets, or third-party libraries if present: `@radix-ui/react-tooltip@1.1.8`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/use-mobile.ts
Purpose or role in the project: This file exports a custom React hook to detect if the application is being viewed on a mobile-sized screen.
Main components, functions, classes, or constants with brief technical descriptions:
- `MOBILE_BREAKPOINT`: A constant set to 768 pixels.
- `useIsMobile`: A custom hook that uses the `window.matchMedia` API to check if the screen width is less than the `MOBILE_BREAKPOINT`. It sets up an event listener to update its state when the window is resized across the breakpoint.
Important interactions or dependencies with other files or modules:
- The `Sidebar` component uses this hook to switch between its desktop and mobile (Sheet) layout.
Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard and efficient way to handle responsive logic in a React application without relying on re-renders on every window resize event.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/components/ui/utils.ts
Purpose or role in the project: This is a utility file that exports a helper function for conditionally joining CSS class names.
Main components, functions, classes, or constants with brief technical descriptions:
- `cn`: A function that combines the functionality of `clsx` (for conditionally applying classes) and `tailwind-merge` (for intelligently merging and overriding Tailwind CSS classes).
Important interactions or dependencies with other files or modules:
- Almost every UI component in the `components/ui` directory imports and uses this `cn` function to construct their `className`.
Special configurations, assets, or third-party libraries if present: `clsx`, `tailwind-merge`.
Notable implementation details, architectural patterns, or non-trivial techniques: This is a standard and highly recommended utility in modern Tailwind CSS projects to make component styling more robust and predictable.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/guidelines/Guidelines.md
Purpose or role in the project: This markdown file serves as a set of system guidelines for an AI model. Its purpose is to instruct the AI on how to generate or modify code to align with the project's specific coding standards, design system rules, and general best practices.
Main components, functions, classes, or constants with brief technical descriptions:
- The file is structured with comments and examples.
- General guidelines: Contains examples of high-level rules like preferring flexbox/grid over absolute positioning and keeping code clean and modular.
- Design system guidelines: Provides a section for rules related to the project's visual design and component usage, such as font sizes, date formats, and component-specific rules (e.g., when to use a primary button).
- Button Component Example: A detailed subsection shows how to document a specific component's purpose, variants, and usage rules for the AI.
Notable implementation details, architectural patterns, or non-trivial techniques: This file represents a form of "prompt engineering" or providing "in-context learning" for an LLM. By including this file in the context sent to the AI, developers can guide its output to be more consistent and adhere to project-specific constraints.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/hooks/useSmartPolling.ts
Purpose or role in the project: This file defines a custom React hook that provides a "smart" polling mechanism. It periodically calls a function but pauses or slows down when the browser tab is not visible to save resources.
Main components, functions, classes, or constants with brief technical descriptions:
- `useSmartPolling`: The custom hook. It takes a configuration object with a `callback` function, a base `interval`, an `enabled` flag, and a `maxInterval`.
- Core Logic:
  - It uses `useEffect` to set up and tear down the polling logic.
  - It uses the `document.visibilityState` property from the Page Visibility API to check if the tab is active.
  - When the tab is hidden, it implements an exponential backoff strategy, doubling the polling interval on each iteration up to `maxInterval`.
  - When the tab becomes visible again, it resets the interval to the base value and can trigger an immediate poll.
  - It uses `useRef` to store the interval timer, callback function, and enabled status to avoid issues with stale closures in `useEffect`.
Important interactions or dependencies with other files or modules:
- This hook is used in `TestRunDetailsModule.tsx` to periodically refresh test run results, although it is disabled by default in that file.
Notable implementation details, architectural patterns, or non-trivial techniques: This is a sophisticated hook that demonstrates good performance practices by avoiding unnecessary background work when the user is not actively viewing the page. The use of exponential backoff is a robust strategy for reducing server load from inactive clients.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/hooks/useTestCaseDetails.ts
Purpose or role in the project: This file provides a set of custom hooks for managing server state related to a test case's details, such as its activities, comments, and defects. It uses `@tanstack/react-query` to handle data fetching, caching, and mutations.
Main components, functions, classes, or constants with brief technical descriptions:
- Query Keys: Exports `testCaseActivityKeys`, `testCaseCommentKeys`, and `testCaseDefectKeys`. These are structured objects that define unique keys for caching different types of data in `react-query`, enabling targeted cache invalidation.
- `useTestCaseActivities`, `useTestCaseComments`, `useTestCaseDefects`: These are `useQuery` hooks that wrap the corresponding service calls to fetch lists of activities, comments, or defects for a given `caseId`.
- `useCreateComment`, `useUpdateComment`, `useDeleteComment`: These are `useMutation` hooks for performing CRUD operations on comments. On success, they use `queryClient.invalidateQueries` to automatically refetch the relevant data and update the UI.
- `useCreateDefect`, `useUpdateDefect`, `useDeleteDefect`: A similar set of `useMutation` hooks for managing defects.
Important interactions or dependencies with other files or modules:
- Depends heavily on `@tanstack/react-query` for all its functionality.
- It calls methods from `TestCaseActivityService`, `TestCaseCommentService`, and `TestCaseDefectService` to interact with the backend API.
Special configurations, assets, or third-party libraries if present: `@tanstack/react-query`.
Notable implementation details, architectural patterns, or non-trivial techniques: This file is an excellent example of abstracting data-fetching and mutation logic into reusable hooks. This pattern centralizes server state management, separates it from UI components, and provides benefits like caching, automatic refetching, and optimistic updates.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/hooks/useTestRunResults.ts
Purpose or role in the project: This file provides custom hooks for managing the state of test run results using `@tanstack/react-query`.
Main components, functions, classes, or constants with brief technical descriptions:
- `testRunResultKeys`: An object defining structured query keys for caching test run results, separating keys for lists and individual details.
- `useTestRunResults`: A `useQuery` hook to fetch all results for a specific `runId`.
- `useTestRunResult`: A `useQuery` hook to fetch a single result for a specific `caseId` within a `runId`.
- `useUpsertTestRunResult`: A `useMutation` hook that handles both creating and updating a test run result. It accepts an `isUpdate` flag to decide whether to call `TestRunResultService.updateResult` or `createResult`.
- `useDeleteTestRunResult`: A `useMutation` hook for deleting a test run result.
- Cache Invalidation: The mutation hooks use `queryClient.invalidateQueries` on success to ensure that cached data is refetched and the UI is updated.
Important interactions or dependencies with other files or modules:
- It uses `@tanstack/react-query`.
- It interacts with the `TestRunResultService` to communicate with the backend.
Special configurations, assets, or third-party libraries if present: `@tanstack/react-query`.
Notable implementation details, architectural patterns, or non-trivial techniques: The `useUpsertTestRunResult` hook is a good example of combining similar mutations into a single, more flexible hook.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/hooks/useTestRuns.ts
Purpose or role in the project: This file provides custom hooks for managing the state of test runs using `@tanstack/react-query`.
Main components, functions, classes, or constants with brief technical descriptions:
- `testRunKeys`: An object defining structured query keys for caching test run data.
- `useTestRuns`: A `useQuery` hook to fetch a list of all test runs, with an optional `projectId` filter.
- `useTestRun`: A `useQuery` hook to fetch the details of a single test run by its `runId`.
- `useCreateTestRun`, `useUpdateTestRun`, `useDeleteTestRun`: `useMutation` hooks for creating, updating, and deleting test runs. They use `queryClient.invalidateQueries` to manage cache invalidation on success.
Important interactions or dependencies with other files or modules:
- It uses `@tanstack/react-query`.
- It interacts with `TestRunService` for all API communication.
Special configurations, assets, or third-party libraries if present: `@tanstack/react-query`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/index.css
Purpose or role in the project: This is the main global stylesheet for the application. It uses Tailwind CSS syntax and `@layer` rules.
Main components, functions, classes, or constants with brief technical descriptions:
- Tailwind CSS Imports: It starts with the directive `/*! tailwindcss v4.1.3 | MIT License | https://tailwindcss.com */`, indicating it's a Tailwind-generated file.
- `@layer properties`: Defines custom CSS properties (variables) that Tailwind uses for its transformations. This is part of Tailwind's engine.
- `@layer theme`: Defines the application's design tokens as CSS variables. It includes fonts, a wide range of colors (red, orange, teal, etc.), spacing units, container sizes, text sizes, and font weights.
- `@layer base`: Defines base styles for HTML elements, resetting default margins and paddings, and setting default typography. It also sets default background and foreground colors.
- `@layer utilities`: Contains the utility classes generated by Tailwind CSS based on the configuration. This is a very large section with classes for layout, spacing, typography, colors, borders, etc.
- Custom Scrollbar: Includes custom CSS rules for styling the scrollbar using `-webkit-scrollbar` properties and the standard `scrollbar-color`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- It uses the modern Tailwind CSS approach of defining a design system through CSS variables within the `:root` selector.
- The use of the Oklch color space (`oklch(...)`) for defining colors is a modern technique that offers a more perceptually uniform color model.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/main.tsx
Purpose or role in the project: This is the main entry point for the React application.
Main components, functions, classes, or constants with brief technical descriptions:
- It imports `createRoot` from `react-dom/client` to initialize the React application.
- It imports the main `App` component and the global stylesheet `index.css`.
- It initializes a `QueryClient` from `@tanstack/react-query`.
- `QueryClient Configuration`: It sets default options for all queries, including a `staleTime` of 5 minutes (data is considered fresh for this duration), a `gcTime` (garbage collection/cache time) of 10 minutes, disabling `refetchOnWindowFocus`, and setting `retry` to 1.
- Rendering: It renders the `App` component wrapped within a `QueryClientProvider`, making the query client available to all components in the application.
Important interactions or dependencies with other files or modules:
- It is the root of the component tree, rendering the `App` component.
- It sets up the `@tanstack/react-query` provider, which is essential for all the custom data-fetching hooks used throughout the application.
Special configurations, assets, or third-party libraries if present: `react-dom/client`, `@tanstack/react-query`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/aggregate-versions.ts
Purpose or role in the project: This service file provides methods for interacting with the backend API endpoints related to AI-generated aggregate versions of a project.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines `AggregateVersion` and `AggregateVersionsResponse` interfaces to type the data returned from the API.
- `AggregateVersionService`: An object that encapsulates the API calls.
  - `getVersions`: Fetches the version history for a project.
  - `createVersion`: Sends a request to create a new version (snapshot) of the current aggregate data.
  - `revertToVersion`: Sends a request to revert the project's aggregate data to a specific older version.
- It uses the `makeAuthenticatedRequest` helper for making authenticated API calls.
Important interactions or dependencies with other files or modules:
- This service is used by the `AggregateVersionManager` component to fetch and manage version data.
- It depends on the `makeAuthenticatedRequest` function from `auth.ts`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/ai-healing.ts
Purpose or role in the project: This service file contains the logic for interacting with the AI healing backend API. It defines the request/response structures and provides methods to initiate a healing process and save the results.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines detailed interfaces for the healing process: `HealTestCaseRequest`, `HealTestCaseResponse`, `SaveHealedTestCaseRequest`, and `SaveHealedTestCaseResponse`. These interfaces precisely type the complex data structures involved, including the original and healed test cases and aggregates.
- `AIHealingService`: A class with static methods for API interaction.
  - `healTestCase`: Constructs the request payload and makes a POST request to the `/api/v1/ai/heal-test-case` endpoint. It includes debug logging to console log the backend's response, which is a useful development practice.
  - `saveHealedTestCase`: Makes a POST request to the `/api/v1/ai/save-healed-test-case` endpoint to persist the AI-generated changes.
Important interactions or dependencies with other files or modules:
- This service is used by `HealTestCaseModule` and `TestCaseDetailsModule` to power the AI healing feature.
- It uses the `makeAuthenticatedRequest` helper from `auth.ts`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/ai-project-import.ts
Purpose or role in the project: This service handles the complex process of creating a new project by analyzing a ZIP file of source code using AI. It provides methods for token estimation, chunked processing, and the final import.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines several detailed interfaces like `AIImportRequest`, `TokenEstimationResponse`, and `ProjectImportResponse` to model the data exchanged with the backend during the import process.
- `AI_PROVIDERS`: A constant object that contains a hardcoded list of supported AI providers (OpenAI, Anthropic, Gemini) and their available models, including metadata like max tokens and context window size.
- `AIProjectImportService`: A class with static methods for each step of the AI import process.
  - `estimateTokens`: Estimates the token count for a given text content.
  - `estimateZipTokens`: Estimates token count directly from a ZIP file by uploading it.
  - `prepareChunks`: Sends the full code content to the backend to be split into manageable chunks for AI processing.
  - `processChunk`: Sends a single chunk to the AI for analysis.
  - `aggregateChunks`: Sends the results from all processed chunks to be combined into a final, coherent project structure.
  - `importProjectFromZip`: The main entry point for a simpler, single-call import process where the backend handles all the steps.
  - `validateZipFile`, `formatFileSize`, `estimateProcessingTime`: Client-side utility functions to provide feedback to the user before uploading.
Important interactions or dependencies with other files or modules:
- This service is primarily used by the `CreateProjectWizard` component.
- It uses `makeAuthenticatedRequest` for API calls and `showToast` for notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/ai-settings.ts
Purpose or role in the project: This service file provides methods for managing global AI settings, providers, and models within the application.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines types for AI settings and data, including `AIProvider`, `ModelCapability`, `GlobalAISettings`, `UsageStats`, and `ProviderTestResult`.
- `PROVIDER_MODELS`: A large, hardcoded constant object containing detailed lists of models for various providers (OpenAI, Anthropic, Gemini, Vertex, OpenRouter). This data is based on `ai-tokenizer` information and includes details like max tokens and context window size.
- `AISettingsService`: A class with static methods for managing AI settings.
  - `getProviders`, `getGlobalSettings`, `updateGlobalSettings`: Standard CRUD operations for AI provider configurations and global settings.
  - `getModelCapabilities`: Fetches detailed capability information for different AI models from the backend.
  - `getUsageStats`: Fetches AI usage analytics.
  - `testProviderConnection`: Sends a request to the backend to test the connectivity and credentials for a specific AI provider.
  - `getPromptTemplates`: Fetches master prompt templates from the backend.
Important interactions or dependencies with other files or modules:
- This service is used by components that offer AI features, such as `HealTestCaseModule` and `AIProjectImportService`, to get lists of available models and default settings.
- It uses `makeAuthenticatedRequest` for API calls and `toast` from `sonner` for notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/auth.ts
Purpose or role in the project: This is the central authentication service for the frontend application. It manages JWT (JSON Web Tokens) for authentication, including login, logout, and automatic token refreshing.
Main components, functions, classes, or constants with brief technical descriptions:
- `API_BASE`: A constant for the backend API URL, configured via Vite environment variables.
- `refreshAccessToken`: An async function that uses the stored refresh token to request a new access token from the `/api/v1/auth/refresh` endpoint. It handles failures by logging the user out.
- `makeAuthenticatedRequest`: A crucial wrapper function for `fetch`. It automatically adds the `Authorization: Bearer <token>` header to requests. If a request fails with a 401 (Unauthorized) status, it transparently attempts to refresh the access token and then retries the original request with the new token.
- `login`: An async function that sends credentials to the `/api/v1/auth/login` endpoint. On success, it stores the access and refresh tokens in `localStorage`. It includes robust error handling to parse different error formats from the backend.
- `logout`: A function that clears all authentication-related items from `localStorage` and dispatches a custom `auth_logout` event to notify the application. It also makes a call to the backend logout endpoint to invalidate the refresh token.
- `isAuthenticated`, `validateSession`: Helper functions to check the user's authentication status. `validateSession` is more robust as it makes an API call to `/api/v1/auth/me` to confirm the token is still valid.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The `makeAuthenticatedRequest` function implements a sophisticated request interception and retry mechanism for handling token expiration. It uses a queuing system (`refreshSubscribers`) to handle multiple concurrent failed requests, ensuring that the token is only refreshed once.
- The service uses `localStorage` for token persistence.
- It uses a custom event (`auth_logout`) to signal logout across the application, which is a good pattern for decoupling components from the auth service.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/dashboard.ts
Purpose or role in the project: This service file provides methods for fetching data specifically for dashboard and analytics views.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines data structures for dashboard content, including `RecentActivity`, `ProjectHealth`, `DashboardStats`, `ProjectAnalytics`, and `ExecutionReport`.
- `dashboardService`: An object that encapsulates the API calls.
  - `getDashboardStats`: Fetches high-level statistics for the main dashboard.
  - `getProjectAnalytics`: Fetches time-series and distribution data for a specific project's dashboard.
  - `getExecutionReport`: Fetches a detailed report for a specific test run.
Important interactions or dependencies with other files or modules:
- This service is used by the main `Dashboard` component (not included in the chunk) and potentially other analytics-focused components.
- It uses the `makeAuthenticatedRequest` helper from `auth.ts`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/milestones.ts
Purpose or role in the project: This service file provides methods for performing CRUD (Create, Read, Update, Delete) operations on milestones.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `Milestone`, `CreateMilestoneData`, `UpdateMilestoneData`.
- `MilestoneService`: A class that encapsulates methods for interacting with the `/api/v1/milestones/` API endpoints.
  - It includes methods for `getMilestones` (with optional project filtering), `createMilestone`, `getMilestone`, `updateMilestone`, `deleteMilestone`, and fetching related entities like `getMilestoneTestCases` and `getMilestoneTestRuns`.
- `getAuthHeaders`: A private method to construct the authentication headers for each request. Unlike other services, this one uses raw `fetch` instead of the `makeAuthenticatedRequest` helper.
Important interactions or dependencies with other files or modules:
- This service is used by components that manage milestones, such as `ProjectDetailsModule`.
Notable implementation details, architectural patterns, or non-trivial techniques:
- The `createMilestone` and `updateMilestone` methods include logic to format date strings into the ISO datetime format expected by the backend (`...T00:00:00`).
- The error handling in `createMilestone` attempts to parse different JSON error structures from the backend to provide a more specific error message.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/project-members.ts
Purpose or role in the project: This service file manages project membership, providing methods to list, add, and remove users from a project.
Main components, functions, classes, or constants with brief technical descriptions:
- `ProjectMember` interface: Defines the data structure for a project member.
- `ProjectMemberService`: An object exposing the API methods.
  - `getMembers`: Fetches the list of members for a given `projectId`.
  - `addMember`: Adds a user to a project by their email address.
  - `removeMember`: Removes a member from a project by their member ID.
Important interactions or dependencies with other files or modules:
- This service is used by the `ProjectDetailsModule` in its "Manage Members" dialog.
- It uses the `makeAuthenticatedRequest` helper from `auth.ts` for its API calls.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/projects.ts
Purpose or role in the project: This service provides all the necessary methods for performing CRUD operations on projects.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `Project`, `ProjectStatistics`, `ProjectWithStats`, `CreateProjectData`, `UpdateProjectData`, `ProjectMember`.
- `ProjectService`: A class containing methods for project-related API calls.
  - `getProjects`: Fetches a list of all projects.
  - `getProjectsWithStats`: Fetches projects along with pre-calculated statistics for each.
  - `getProject`: Fetches a single project by its ID.
  - `createProject`, `updateProject`, `deleteProject`: Standard CRUD methods.
  - `renameProject`: A specific method for updating only the project's name.
  - `getProjectMembers`: Fetches the members of a project.
Important interactions or dependencies with other files or modules:
- This is a core service used by `ProjectsModule`, `ProjectDetailsModule`, and many other components that need project data.
- It uses `makeAuthenticatedRequest` for all API calls.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-case-activities.ts
Purpose or role in the project: This service is responsible for fetching activity logs related to a specific test case.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `TestCaseActivity` and `PaginatedResponse<T>`.
- `TestCaseActivityServiceClass`: A class with methods to fetch activities.
  - `getActivities`: Fetches a paginated list of activities.
  - `getAllActivities`: Fetches all activities up to a limit of 1000, intended for backward compatibility where pagination was not used.
- It uses a local `getHeaders` method with raw `fetch`, not the `makeAuthenticatedRequest` helper.
Important interactions or dependencies with other files or modules:
- Used by `TestCaseDetailsModule` to display the activity feed for a test case.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-case-attachments.ts
Purpose or role in the project: This service manages file attachments for test cases.
Main components, functions, classes, or constants with brief technical descriptions:
- `TestCaseAttachmentServiceClass`: A class with methods for attachment management.
  - `upload`: Handles file uploads. It correctly constructs a `FormData` object to send multiple files in a single POST request.
  - `list`: Fetches the list of existing attachments for a test case.
- It uses a local `getHeaders` method that can skip setting the `Content-Type` header, which is necessary when sending `FormData` so the browser can set it correctly with the boundary.
Important interactions or dependencies with other files or modules:
- Used by `TestCaseDetailsModule` in the "Attachments" tab.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-case-comments.ts
Purpose or role in the project: This service manages comments on test cases.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines types for `TestCaseComment` and its create/update payloads.
- `TestCaseCommentServiceClass`: A class providing full CRUD functionality for comments.
  - `getComments` (paginated), `getAllComments` (unpaginated).
  - `createComment`, `updateComment`, `deleteComment`.
- It uses a local `getHeaders` method with raw `fetch`.
Important interactions or dependencies with other files or modules:
- Used by `TestCaseDetailsModule` in the "Comments" tab.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-case-defects.ts
Purpose or role in the project: This service manages defect logs associated with test cases.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines types for `TestCaseDefect` and its create/update payloads.
- `TestCaseDefectServiceClass`: A class providing full CRUD functionality for defects linked to a test case.
  - `getDefects` (paginated), `getAllDefects` (unpaginated).
  - `createDefect`, `updateDefect`, `deleteDefect`.
- It uses a local `getHeaders` method with raw `fetch`.
Important interactions or dependencies with other files or modules:
- Used by `TestCaseDetailsModule` to log and display defects when a test fails or is blocked.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-cases.ts
Purpose or role in the project: This is a core service for managing test cases, including CRUD operations and versioning.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines detailed types for `TestCaseCreate`, `TestCaseUpdate`, `TestCaseResponse`, and `TestCaseVersion`.
- `TestCaseServiceClass`: The main class with methods for API interaction.
  - `getTestCases`, `getTestCasesBySuite`, `getTestCasesByMilestone`, `getTestCasesByProject`: Various methods for fetching lists of test cases with different filters. The `getTestCasesByProject` method supports pagination and returns statistics.
  - `createTestCase`, `getTestCase`, `updateTestCase`, `deleteTestCase`: Standard CRUD methods.
  - `getTestCaseVersions`, `getTestCaseVersion`: Methods for retrieving the version history of a test case.
- Constants: Exports `TEST_CASE_PRIORITIES` and `TEST_CASE_TYPES` as arrays of objects, which are used to populate dropdowns in the UI.
Important interactions or dependencies with other files or modules:
- This service is fundamental and is used by `ProjectDetailsModule`, `TestCaseDetailsModule`, `TestCaseModal`, and the integration test script.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-plans.ts
Purpose or role in the project: This service manages test plans and the items (test cases) within them.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: Defines types for test plans (`TestPlan`, `CreateTestPlanData`, `UpdateTestPlanData`) and the items within them (`PlanItem`, etc.).
- `TestPlanService`: A class with methods for API interaction.
  - `getTestPlans`, `createTestPlan`, `getTestPlan`, `updateTestPlan`, `deleteTestPlan`: Standard CRUD for test plans.
  - `getPlanItems`, `addTestCaseToPlan`, `updatePlanItem`, `removeTestCaseFromPlan`: CRUD for individual items within a plan.
  - `bulkAddTestCasesToPlan`, `reorderPlanItems`: Methods for performing bulk operations on a plan's items.
- It uses a local `getAuthHeaders` method with raw `fetch`.
Important interactions or dependencies with other files or modules:
- Used by `ProjectDetailsModule` and `TestPlanModal`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-run-results.ts
Purpose or role in the project: This service is responsible for managing the individual execution results of test cases within a specific test run.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `TestRunResult`, `CreateTestRunResultRequest`, `UpdateTestRunResultRequest`.
- `TestRunResultServiceClass`: A class encapsulating the API calls.
  - `getResultForTestCase`: Fetches the result for a single test case within a run. Handles 404s by returning `null`.
  - `createResult`, `updateResult`, `deleteResult`: CRUD methods for a single result.
  - `getAllResultsForRun` (paginated), `getAllResultsForRunUnpaginated`: Methods to fetch all results for a given test run.
- It uses a local `getAuthHeaders` method with raw `fetch`.
Important interactions or dependencies with other files or modules:
- This service is a critical dependency for `TestRunDetailsModule` and `TestCaseDetailsModule` (when in execution mode).

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-runs.ts
Purpose or role in the project: This service manages test runs, which are collections of test cases to be executed.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `TestRunCreate`, `TestRunUpdate`, `TestRunResponse`, `TestExecutionResponse`.
- Constants: Exports `TEST_RUN_STATUSES`, `TEST_RUN_TYPES`, and `EXECUTION_STATUSES` for use in UI components.
- `TestRunServiceClass`: The main class with methods for API interaction.
  - `getTestRuns`, `getTestRunsByProject`: Methods for fetching lists of test runs.
  - `getTestRun`, `createTestRun`, `updateTestRun`, `deleteTestRun`: Standard CRUD methods.
  - `updateTestRunStatus`: A specific method for changing only the status of a run.
  - `getRunTestCases`: Fetches the test cases associated with a run.
  - `createRunFromPlan`: A special method to create a new test run based on an existing test plan.
- It uses a local `getAuthHeaders` method and `toast` for notifications.
Important interactions or dependencies with other files or modules:
- Used by `ProjectDetailsModule`, `TestRunDetailsModule`, and the test run modals.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/test-suites.ts
Purpose or role in the project: This service manages test suites, which are logical groupings of test cases.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `TestSuite`, `CreateTestSuiteData`, `UpdateTestSuiteData`.
- `TestSuiteService`: A class with methods for API interaction.
  - `getTestSuites`: Fetches suites, with an optional project filter.
  - `getTestSuitesByProject`: A dedicated endpoint for fetching suites by project ID.
  - `createTestSuite`, `getTestSuite`, `updateTestSuite`, `deleteTestSuite`: Standard CRUD methods.
- It uses a local `getAuthHeaders` method and includes detailed error message parsing.
Important interactions or dependencies with other files or modules:
- Used by `ProjectDetailsModule` and `TestSuiteModal`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/users.ts
Purpose or role in the project: This is the frontend service for managing users and roles, providing an interface to the backend's user management API.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `User`, `UserCreate`, `UserUpdate`, `UserMeUpdate`, `ChangePasswordRequest`.
- `ROLE_INFO`: A constant object that maps role keys (e.g., 'admin') to display names, descriptions, and UI colors.
- `UserService`: A class with static methods for all user-related API calls.
  - `getMe`, `updateMe`, `changePassword`: Methods for the currently logged-in user to manage their own profile.
  - `getUsers`, `createUser`, `getUser`, `updateUser`, `deleteUser`: Admin-only methods for managing all users in the system.
  - Helper methods: `getRoleInfo`, `formatDate`, `getStatusBadgeColor` for UI formatting.
Important interactions or dependencies with other files or modules:
- This service is the backbone of the `UserManagement` component.
- It uses `makeAuthenticatedRequest` for all API calls and `toast` for notifications.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/services/zip-parser.ts
Purpose or role in the project: This is a client-side service for parsing and analyzing the contents of a ZIP file directly in the browser. It's used for the AI Project Import feature to prepare the source code content before sending it to the backend.
Main components, functions, classes, or constants with brief technical descriptions:
- Interfaces: `ParsedFile` and `ZipParseResult` define the structure of the output.
- `ZipParserService`: A class with static methods.
  - `parseZipFile`: The main method. It takes a `File` object, uses the `JSZip` library to read its contents, and then iterates through the files. It applies filtering rules (excluded directories, supported extensions, max file size), reads file contents as strings, and classifies files (e.g., as code, binary).
  - `buildFileTree`: A private helper method that takes the flat list of parsed files and constructs a hierarchical tree structure.
  - Static Constants: `SUPPORTED_EXTENSIONS`, `EXCLUDED_DIRS`, and `BINARY_EXTENSIONS` define the rules for file processing.
  - Helper methods: `getFileExtension`, `getLanguageFromExtension`, `formatFileSize`, `getSummary`, etc., provide utility functions for processing and presenting the parsed data.
Important interactions or dependencies with other files or modules:
- It is a key dependency for the `CreateProjectWizard` component, which uses it to process uploaded ZIP files.
- It uses the `jszip` library for ZIP file decompression.
Special configurations, assets, or third-party libraries if present: `jszip`.
Notable implementation details, architectural patterns, or non-trivial techniques: This service performs significant data processing on the client side, reducing the need to upload the entire raw ZIP to the server for initial analysis. The `buildFileTree` method is a good example of transforming a flat list into a nested data structure.

FILE: testworthy-pro-dev/testworthy-pro-frontend/src/styles/globals.css
Purpose or role in the project: This file defines the global CSS variables that constitute the application's design system, including themes for both light and dark mode.
Main components, functions, classes, or constants with brief technical descriptions:
- `:root` selector: Defines all the CSS variables for the default (light) theme. This includes colors for background, foreground, card, popover, primary/secondary actions, borders, inputs, and charts. It also defines variables for radius and sidebar-specific colors.
- `.dark` selector: Overrides the CSS variables defined in `:root` with values for the dark theme.
- `@layer base`: Applies base styles, setting the default background and text colors for the `body` and `card` elements.
- Custom Scrollbar: Provides cross-browser styling for the scrollbar, themed according to the application's color scheme.
- Theme Transition: Includes a CSS rule to apply a smooth transition to color-related properties, making the switch between light and dark mode less jarring.
Notable implementation details, architectural patterns, or non-trivial techniques: This file is a clear implementation of a modern, themeable design system using CSS variables. Separating the variable definitions from the utility classes (which are in `index.css`) is a clean architectural choice.

FILE: testworthy-pro-dev/testworthy-pro-frontend/test-cases-integration.js
Purpose or role in the project: This is a standalone Node.js script designed to run integration tests against the test case API endpoints.
Main components, functions, classes, or constants with brief technical descriptions:
- `testTestCasesIntegration`: An async function that orchestrates a series of tests against the `TestCaseService`.
- Test Sequence: The script performs a sequence of actions:
  1. Fetches all test cases.
  2. Fetches test cases for a specific suite.
  3. Creates a new test case.
  4. Updates the newly created test case.
  5. Fetches the updated test case by its ID.
  6. Deletes the test case.
- Console Logging: It logs the status and result of each step to the console.
- Mocking: It includes mock implementations for `localStorage` and `fetch` (using `node-fetch`) to allow the browser-oriented `TestCaseService` to run in a Node.js environment.
Important interactions or dependencies with other files or modules:
- It imports and uses the `TestCaseService`.
- It requires `node-fetch` to be installed if run outside of an environment that provides `fetch`.
Notable implementation details, architectural patterns, or non-trivial techniques: This script serves as a simple integration test suite, verifying that the frontend service can correctly communicate with the backend API for all standard CRUD operations on test cases.

FILE: testworthy-pro-dev/testworthy-pro-frontend/tsconfig.json
Purpose or role in the project: This is the main TypeScript configuration file for the Vite-based React frontend application.
Main components, functions, classes, or constants with brief technical descriptions:
- `compilerOptions`:
  - `target`: "ES2020", specifying the JavaScript version to compile to.
  - `module`: "ESNext", using modern ES modules.
  - `moduleResolution`: "bundler", a modern setting for use with bundlers like Vite.
  - `jsx`: "react-jsx", enabling the modern JSX transform.
  - `strict`: false, `noUnusedLocals`: false, `noUnusedParameters`: false: These settings indicate a looser linting configuration, which is common during rapid development but might be tightened for production.
  - `noEmit`: true, as Vite handles the transpilation and bundling.
- `include`: Specifies that all files within the `src` directory should be included in the TypeScript project.
- `references`: Includes a reference to `tsconfig.node.json`, which is used for Node.js-specific files in the project.

FILE: testworthy-pro-dev/testworthy-pro-frontend/tsconfig.node.json
Purpose or role in the project: This is a supplementary TypeScript configuration file specifically for Node.js-based tooling files within the frontend project, such as the Vite configuration file.
Main components, functions, classes, or constants with brief technical descriptions:
- `compilerOptions`:
  - `composite`: true, indicating this is part of a larger project with multiple `tsconfig.json` files.
  - `module`: "ESNext" and `moduleResolution`: "bundler", to align with modern Node.js and Vite standards.
- `include`: Specifies that it should only apply to `vite.config.ts`.

FILE: testworthy-pro-dev/testworthy-pro-frontend/vite.config.ts
Purpose or role in the project: This is the configuration file for Vite, the build tool used for the frontend application.
Main components, functions, classes, or constants with brief technical descriptions:
- `defineConfig`: The main function from Vite to define the configuration.
- `plugins`: Configures the `@vitejs/plugin-react-swc` plugin, which enables Fast Refresh and SWC-based compilation for React.
- `resolve.alias`: Contains a very large list of aliases. This is a notable feature. It maps specific versions of third-party libraries (e.g., `'@radix-ui/react-tooltip@1.1.8'`) to a shorter import path (e.g., `'@radix-ui/react-tooltip'`). This technique can help enforce consistent dependency versions across the project. It also sets up the `'@'` alias to point to the `src` directory.
- `build`: Configures the production build, setting the output directory to `build` and the target to `esnext`.
- `server`: Configures the development server to run on port 3000 and to automatically open a browser window on startup.
Special configurations, assets, or third-party libraries if present: `@vitejs/plugin-react-swc`, `vite`.

FILE: testworthy-pro-dev/ubuntu-setup.sh
Purpose or role in the project: This is a comprehensive shell script designed to fully automate the setup and deployment of the TestWorthy Pro application on a fresh Ubuntu server or VM.
Main components, functions, classes, or constants with brief technical descriptions:
- Functions: The script is well-structured with functions for each major task: `check_user`, `check_system`, `update_system`, `setup_firewall`, `install_docker`, `optimize_system`, `setup_testworthy`, `create_service`, `setup_backup`, and `deploy_application`.
- System Setup: It updates system packages, configures the UFW firewall to allow necessary ports (SSH, HTTP/S, app ports), and installs Docker and Docker Compose.
- Optimization: It increases system-wide file descriptor limits and optimizes kernel network parameters in `/etc/sysctl.conf` for better performance under load.
- Application Setup: It clones the application's Git repository, creates a `.env` file from the example, generates a secure JWT secret, and prompts the user to fill in the rest of the configuration.
- Service Management: It creates a `systemd` service file (`testworthy.service`), enabling the application to be managed like a standard system service (e.g., `sudo systemctl start testworthy`).
- Backup: It creates a backup script (`backup-testworthy.sh`) and sets up a cron job to run it daily, providing automated backups of the application code and configuration.
- Deployment: It includes logic to handle Docker group permissions and then executes the project's own `deploy.sh` script to build and run the application containers.
- User Interaction: It uses colored output for clarity and prompts the user for confirmation and necessary input (like the repository URL).
Notable implementation details, architectural patterns, or non-trivial techniques: This is a robust and thorough deployment automation script. The inclusion of system optimization, firewall configuration, `systemd` service creation, and automated backups goes well beyond a simple deployment script and aims to create a production-ready environment.

FILE: testworthy-pro-dev/wait-for-postgres.sh
Purpose or role in the project: This is a utility shell script commonly used in Docker Compose environments to ensure that a service (like the backend API) waits for the PostgreSQL database to be fully ready before it starts.
Main components, functions,classes, or constants with brief technical descriptions:
- The script uses a `set -e` command to exit immediately if any command fails.
- It determines the database host and port from environment variables (`POSTGRES_HOST`, `POSTGRES_PORT`), with defaults provided.
- It uses an `until` loop with the `pg_isready` command-line utility. `pg_isready` is a PostgreSQL client tool that checks the connection status of a PostgreSQL server.
- The loop continues to sleep for 2 seconds and retry until `pg_isready` returns a success status code.
- Once the database is ready, it uses `exec "$@"` to execute whatever command was passed as arguments to the script. This is typically the command to start the main application server.
Important interactions or dependencies with other files or modules:
- This script is intended to be used as an entrypoint command for a Docker container in a `docker-compose.yml` file. For example: `command: ["/app/wait-for-postgres.sh", "uvicorn", "main:app", "--host", "0.0.0.0"]`.
- It depends on the `pg_isready` utility, which must be available in the container's environment (usually by installing `postgresql-client`).